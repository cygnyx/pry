 {

"title":"pry",

"tag":"CouchApp Literate Programming",

"version":"0.0.1",

"_id":"_design/pry",

"rewrites":[
   {
       "from": "",
       "to": "."
   },
   {
       "from": "/README.html",
       "to": "_show/README.html"
   },
   {
       "from": "/README.md",
       "to": "_show/README.md"
   },
   {
       "from": "/README.json",
       "to": "_show/README.json"
   },
   {
       "from": "editor",
       "to": "_show/editor"
   },
   {
       "from": "*",
       "to": "_show/404"
   }
],

"shows":{
   "404": "function(doc, req){ return {body: '<h1>404 - Document not found</h1>\\n'}, headers: {'Content-Type': 'text/html'}}}",
   "editor": "function(doc, req){ return {body: require('main').edit.call(this, req), headers: {'Content-Type': 'text/html'}}}",
   "README.md": "function(doc, req){ return {body: this['README.md'], headers: {'Content-Type': 'text/markdown'}}}",
   "README.html": "function(doc, req){ return {body: require('main').weave.call(this), headers: {'Content-Type': 'text/html'}}}",
   "README.json": "function(doc, req){ return {body: require('main').tangle.call(this), headers: {'Content-Type': 'text/plain'}}}"
},

"editorcontent":"<ul class='tabs'>\n  <li><a href='#tab1'>Document</a></li>\n  <li><a href='#tab2'>Source Code</a></li>\n  <li><a href='#tab3'>HTML</a></li>\n  <li><a href='#tab4'>Update</a></li>\n</ul>\n\n<div class='display'>\n<div id='tab1'><input type=\"text\" id='_src' value=''></input><textarea id='_editor'></textarea></div>\n<div id='tab2'><div id='_code'></div></div>\n<div id='tab3'></div>\n<div id='tab4'></div>\n</div>",

"editorstyle":"html, body, div, span, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre,\nabbr, address, cite, code, del, dfn, em, img, ins, kbd, q, samp,\nsmall, strong, sub, sup, var, b, i, dl, dt, dd, ol, ul, li, a, textarea, input,\nfieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td,\narticle, aside, canvas, details, figcaption, figure,\nfooter, header, hgroup, menu, nav, section, summary, time, mark, audio, video {\n  display: block;\n  margin: 0;\n  padding: 0;\n  border: 0;\n  outline: 0;\n  line-height: 140%;\n  font-size: inherit;\n  color: black;\n  vertical-align: baseline;\n  text-decoration: none;\n  background: transparent;\n}\n\na, code, span, b, i, em { display: inline; }\n\nbody {\n  font-size: 100%;\n}\n#tab1 #_src, #tab1 #_editor, .tabs li {\n  border: solid black 1px;\n}\n\n.tabs li:hover, #tab1 #_editor:focus, #tab1 #_src:focus {\n  border: solid orange 1px;\n}\n.display, .tabs {\n  margin: 0.4em;\n}\n\n#tab1 #_editor, #tab1 #_src {\n  width: 99%;\n  font-family: Courier, monospace;\n  padding: 0.5%;\n}\n\n#tab1 #_editor {\n  resize: none;\n  height: 40em;\n}\n.tabs li {\n  list-style: none;\n  display: inline;\n  padding: 0.4em;\n}\n\n.tabs a, .tabs input {\n  display: inline-block;\n  color: gray;\n}\n\n.tabs a.active {\n  color: black;\n}\n.display #_code {\n  white-space: pre;\n  overflow: visible;\n  word-wrap: break-word;\n}\n\n@media print {\n  .tabs {\n    display: none;\n  }\n}",

"editorscript":"var tab2todo = true\n\nfunction longwait() {\n  var st = new Date()\n  if (tab2todo) {\n    setuptab2()\n    this.timeout = setTimeout(longwait, 50)\n  } else {\n    setuptab3()\n  }\n  tab2todo = !tab2todo\n  var ms = new Date() - st\n  if (ms < 500) ms = 500\n  this.delay = 2 * ms\n}\nfunction putDoc1(md) {\n  $(\"#_editor\").text(md)\n  setuptab1()\n  this.timeout = setTimeout(longwait, 50)\n}\n\nfunction putDoc(errflag, md) {\n  if (errflag)\n    md = ''\n  else\n    md = md[mdref]\n  putDoc1(md)\n}\nfunction makeurl(path) {\n  return location.protocol + '//' + location.host + '/' + path\n}\n$(document).ready(function () {\n  $(\"#_editor\").keyup(function() {\n    if (this.timeout) clearTimeout(this.timeout)\n    tab2todo = true\n    this.timeout = setTimeout(longwait, this.delay || 1000)\n  })\n  $(\"#_src\").val(mddb)\n  markover = require('markover')\n\n  if (typeof md == \"undefined\") {\n    var url = makeurl(mddb)\n    getDocument(url, putDoc)\n  } else\n    putDoc1(md)\n})\nfunction escape(str) {\n  return str\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n}\nvar markover\n\nfunction tangleDoc() {\n  var src = $('#_editor')[0].value\n  var el = $('#_code')\n  var res\n  if (typeof mdref == \"undefined\" || mdref == \"\")\n    res = markover.tangleJSON(src)\n  else\n    res = markover.tangleJSON(src, {sourcetarget: mdref})\n  return res\n}\nfunction setuptab1() {\n  $(\"#_editor\")[0].focus()\n}\n\nfunction setuptab2() {\n  var el = $('#_code')\n  var txt = tangleDoc()\n  el.text(txt)\n}\n\nfunction setuptab3() {\n  var src = $('#_editor')[0].value\n  var el = $('#tab3')\n  var txt = markover.weaveJSON(src, {contentonly: true})\n  el.html(txt)\n}\n\nfunction setuptab4() {\n  var src = $('#_editor')[0].value\n  var url = $('#_src')[0].value.split('/')\n  url = url[0]\n  var txt = tangleDoc()\n  var json = JSON.parse(txt)\n  var id = json._id\n  json[mdref] = src\n  url = [url, id].join('/')\n  $('#tab4').html('</h1>Updating ' + id + '</h1>')\n  url = makeurl(url)\n  updatedoc(url, json)\n}\n\nvar editfunction = {\n  tab1: function(){setuptab1()},\n  tab4: function(){setuptab4()}\n}\n$('ul.tabs').each(function() {\n  var active, content, links = $(this).find('a'), inputs = $(this).find('input')\n\n  active = $(links[0])\n  active.addClass('active')\n\n  content = $(active[0].hash)\n\n  links.not(active).each(function () {\n    $(this.hash).hide()\n  })\n\n  $(this).on('click', 'a', function(e){\n    active.removeClass('active')\n    content.hide()\n\n    active = $(this)\n    content = $(this.hash)\n\n    active.addClass('active')\n\n    var f = editfunction[this.hash.substring(1)]\n    if (typeof f !== \"undefined\") {\n       f()\n    }\n    content.show()\n\n    e.preventDefault()\n  })\n})\nvar require = function require(name) {\n  if (require.loaded[name])\n    return require.loaded[name]\n  throw new Error(\"module missing:\" + name)\n}\nrequire.loaded = {}\nfunction getDocument(url, cb, data) {\n  $.ajax({\n    url: url,\n    dataType: 'json'\n  })\n  .done(function(d, s, x) {\n    cb(false, x.responseJSON, url, data)\n  })\n  .fail(function(x, s, e) {\n    cb(true, x.responseJSON, url, data)\n  })\n}\nfunction putDocument(url, doc, cb) {\n  $.ajax({\n    url: url,\n    type: 'PUT',\n    data: JSON.stringify(doc),\n    contentType: 'application/json',\n    dataType: 'json'\n  })\n  .done(function(d, s, x) {\n    cb(false, x.responseJSON)\n  })\n  .fail(function(x, s, e) {\n    cb(true, x.responseJSON)\n  })\n}\nfunction updatedoc(url, json) {\n  getDocument(url, updatedoc1, json)\n}\nfunction updatedoc1(errflag, resp, url, doc) {\n  var rev\n  var doit = false\n  var err\n  if (errflag) {\n    if (resp) {\n      err = resp.error\n      doit = resp.error == \"not_found\"\n    } else {\n      doit = true\n    }\n  } else {\n    doit = true\n    doc._rev = resp._rev\n  }\n  if (!doit)\n    $('#tab4').html('</h1>Update Error: ' + (err || \"unknown\") + '</h1>')\n  else {\n    $('#tab4').html('</h1>Updating ' + url + '</h1>')\n    putDocument(url, doc, updatedocwithrev)\n  }\n}\nfunction updatedocwithrev(errflag, doc) {\n  if (errflag)\n    $('#tab4').html('</h1>Update Error: ' + \"unknown\" + '</h1>')\n  else\n    $('#tab4').html('</h1>Updated ' + doc.id + ' to revision ' + doc.rev + '</h1>')\n}",

"main":"!(function() {\n\nvar markover = require('markover')\n\nvar main = {\n  weave: function () {\n    return markover.weaveJSON(this['README.md'])\n  },\n  tangle: function() {\n    return markover.tangleJSON(this['README.md'], {sourcetarget: 'README.md'})\n  },\n  fixup: function(str) {\n    return str.replace(/<\\/script>/gm, '<&#'+'47;script>')\n  },\n  quotestring: function(code) {\n    return ('\"' +\n      code\n        .replace(/\\\\/gm, '\\\\\\\\')\n        .replace(/\\\"/gm /*\"*/, '\\\\\"')\n        .replace(/\\n/gm , '\\\\n')\n        .replace(/\\t/gm , '\\\\t')\n      + '\"')\n  },\n  edit: function(req) {\n    var mdref = 'README.md'\n    var p = req.path\n    var mddb = p.slice(0,3).join('/')\n    var src\n    if (req.query.md) {\n      mdref = req.query.md\n    }\n    if (req.query.id) {\n      mddb = req.query.id\n    } else\n      src = main.quotestring(main.fixup(this[mdref]))\n    var buf = []\n    buf.push(this.edithead)\n    buf.push(this.editorstyle)\n    buf.push('</style>'); // syntax help\n\n    ['https://code.jquery.com/jquery-2.1.3.min.js'].forEach(function(e){\n      buf.push('<script type=\"text/javascript\" src=\"'+e+'\"></'+'script>')\n    })\n\n    buf.push(\"</head><body>\")\n    buf.push(this.editorcontent)\n    buf.push(\"</body></html>\")\n    buf.push('<script type=\"text/javascript\">')\n    buf.push('var mdref = \"' + mdref + '\"')\n    buf.push('var mddb = \"' + mddb + '\"')\n    buf.push('var md ' + (src ? (' = ' + src) : ''))\n    buf.push(this.editorscript)\n    var self = this\n    var incs = [\"markover\"]\n    var e\n    var r\n    var i\n    var exports = {}\n    var mods = []\n\n    for(i = 0; i < incs.length; i++) {\n      e = incs[i]\n      if (exports[e] == undefined && self[e] != undefined) {\n        main.scanrequire(incs, self[e])\n        if (self[e] != null) {\n          mods.push([e, self[e]])\n          exports[e] = true\n        }\n      }\n    }\n    i = mods.length\n    while ( (--i) >= 0) {\n      e = mods[i][0]\n      r = mods[i][1]\n      buf.push('require.module = {}')\n      buf.push('require.exports = {}')\n      buf.push(\"require.loading = function (module, exports, require) {\")\n      buf.push(main.fixup(r))\n      buf.push(\"}\")\n      buf.push(\"require.loading(require.module, require.exports, require)\")\n      buf.push('if (typeof require.module.exports == \"undefined\") require.module.exports = require.exports')\n      buf.push('require.loaded[\"' + e + '\"] = require.module.exports')\n      buf.push('delete require.module.exports')\n    }\n    buf.push('delete require.loading')\n    buf.push('delete require.module')\n    buf.push('delete require.exports')\n    buf.push('</'+'script>')\n    buf.push(\"\")\n    return buf.join('\\n')\n  },\n  scanrequire: function(incs, str) {\n    var m = str.match(/require\\(['\"]([^'\"]*)['\"]\\)/gm)\n    if (m != null) {\n      m.forEach(function(e) {\n        var name = e.substring(9,e.length-2)\n        if (incs.indexOf(name) == -1)\n          incs.push(name)\n      })\n    }\n  }\n}\n\nmodule.exports = main\n\n}).call(function () {\n        return this || (typeof window !== 'undefined' ? window : global)\n})",

"edithead":"<!DOCTYPE html><html><head>\n<meta charset=\"utf-8\">\n<meta http-equiv=\"Content-Language\" content=\"en\">\n<meta name=\"viewport\" content=\"initial-scale=1\">\n<title>Editor</title>\n<style>",

"head":"<!DOCTYPE html>\n<html lang=\"en\" class=\"\">\n<head>\n  <meta charset=\"utf-8\">\n  <meta http-equiv=\"Content-Language\" content=\"en\">\n  <meta name=\"viewport\" content=\"initial-scale=1\">",

"transition":"</head>\n<body>",

"tail":"</body>\n</html>",

"headstylesheet":"html, body, div, span, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre,\nabbr, address, cite, code, del, dfn, em, img, ins, kbd, q, samp,\nsmall, strong, sub, sup, var, b, i, dl, dt, dd, ol, ul, li, a,\nfieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td,\narticle, aside, canvas, details, figcaption, figure,\nfooter, header, hgroup, menu, nav, section, summary, time, mark, audio, video {\n  display: block;\n  margin:0;\n  padding:0;\n  border:0;\n  outline:0;\n  line-height: 140%;\n  font-size: inherit;\n  color: black;\n  vertical-align:baseline;\n  text-decoration: none;\n  background:transparent;\n}\n\na, code, span, b, i, em { display: inline; }\n\nbody {\n  font-size: 100%;\n}\n\n@media print {\n  body {\n    font-size: 80%;\n  }\n}",

"stylesheet":"#content {\n  font-family: \"HelveticaNeue-Light\", \"Helvetica Neue Light\", \"Helvetica Neue\", Helvetica, Arial, \"Lucida Grande\", sans-serif; \n}\n\n#content #title {\n  clear: both;\n  text-align: center;\n  font-size: 140%;\n  font-weight: bold;\n  margin: 2em 0 0 0;\n}\n\n#content #tag {\n  clear: both;\n  text-align: center;\n  font-size: 110%;\n  margin: 0 0 1em 0;\n}\n#content #toc {\n  padding: 0 0 0 1em;\n  max-width: 96%;\n  page-break-after: always;\n}\n\n@media screen and (min-width: 641px) {\n  #content #toc {\n    float: left;\n    max-width: 26%;\n  }\n}\n\n#content .tocsn {\n  float: left;\n}\n\n#content .tocsr {\n  overflow: hidden;\n}\n\n#content #toc ol {\n  list-style-type: none;\n}\n\n#content #toc ol ol {\n  margin: 0 0 0 1em;\n}\n#content #doc,\n#content #toc {\n  margin: 0 1em 0 1em;\n}\n\n#content p { text-indent: 1em; }\n\n#content code { font-size: 120%; }\n\n#content pre code {\n  font-family: \"Courier New\", Courier, monospace;\n  font-size: 100%;\n}\n\n@media screen and (min-width: 641px) {\n  #content #doc {\n    overflow: hidden;\n    max-width: 70%;\n  }\n}\n#content pre .field {\n  display:block;\n  margin: 1em 1em 0em 0em;\n}\n\n#content pre .field::after {\n  content: \" :=\";\n}\n#content pre code {\n  display: block;\n  margin: 1em;\n  padding: 1em;\n  border: solid 1px #aaa;\n}\n\n@media screen {\n  #content pre code {\n    background-color: AliceBlue;\n    overflow: auto;\n    max-height: 30em;\n  }\n}\n\n@media print {\n  #content pre {\n    page-break-inside: avoid;\n  }\n  #content pre code {\n    overflow: visible;\n    word-wrap: break-word;\n  }\n}\n@media screen {\n  #content .lang-js { background-color: ivory; }\n  #content .lang-md { background-color: lightyellow; }\n  #content .lang-html { background-color: floralwhite; }\n  #content .lang-json { background-color: honeydew; }\n  #content .lang-css { background-color: cornsilk; }\n  #content .lang-sh { background-color: lemonchiffon; }\n}\n#content h1,\n#content h2,\n#content h3,\n#content h4,\n#content h5,\n#content h6 {\n  margin: 0.5em 0em;\n  page-break-after: avoid\n}\n\n#content h1 { font-size: 140%; }\n#content h2 { font-size: 130%; }\n#content h3 { font-size: 120%; }\n#content h4,\n#content h5,\n#content h6 { font-size: 110%; }\n#content a:hover { color: #aaa; }\n\n#content a:visited,\n#content a { color: #000;}\n\n@media screen {\n  #content a {\n    text-decoration: underline;\n  }\n}\n\n@media print {\n  #content a {\n    text-decoration: none;\n  }\n  #content #doc a[href]:after {\n    content: \" (\" attr(href) \")\";\n    font-size: 90%;\n  }\n}\n.hljs {\n    overflow: auto;\n    padding: 0.5em;\n    color: #333;\n}\n.hljs-comment, .diff .hljs-header, .hljs-javadoc {\n    color: #999;\n    font-style: italic;\n}\n.hljs-keyword, .css .rule .hljs-keyword, .hljs-winutils, .nginx .hljs-title,\n.hljs-subst, .hljs-request, .hljs-status {\n    color: #333;\n    font-weight: bold;\n}\n.hljs-number, .hljs-hexcolor, .ruby .hljs-constant {\n    color: #088;\n}\n.hljs-string, .hljs-tag .hljs-value, .hljs-phpdoc, .hljs-dartdoc, .tex .hljs-formula {\n    color: #d14;\n}\n.hljs-title, .hljs-id, .scss .hljs-preprocessor {\n    color: #900;\n    font-weight: bold;\n}\n.hljs-list .hljs-keyword, .hljs-subst {\n    font-weight: normal;\n}\n.hljs-class .hljs-title, .hljs-type, .vhdl .hljs-literal, .tex .hljs-command {\n    color: #458;\n    font-weight: bold;\n}\n.hljs-tag, .hljs-tag .hljs-title, .hljs-rules .hljs-property, .django .hljs-tag .hljs-keyword {\n    color: #000080;\n    font-weight: normal;\n}\n.hljs-attribute, .hljs-variable, .lisp .hljs-body {\n    color: #008080;\n}\n.hljs-regexp {\n    color: #009926;\n}\n.hljs-built_in {\n    color: #0086b3;\n}\n.hljs-symbol, .ruby .hljs-symbol .hljs-string, .lisp .hljs-keyword,\n.clojure .hljs-keyword, .scheme .hljs-keyword, .tex .hljs-special,\n.hljs-prompt {\n    color: #990073;\n}\n.hljs-preprocessor, .hljs-pragma, .hljs-pi, .hljs-doctype, .hljs-shebang,\n.hljs-cdata {\n    color: #999;\n    font-weight: bold;\n}\n.hljs-deletion {\n    background: #fdd;\n}\n.hljs-addition {\n    background: #dfd;\n}\n.diff .hljs-change {\n    background: #0086b3;\n}\n.hljs-chunk {\n    color: #aaa;\n}\n@media print {\n  .hljs {\n    overflow: visible;\n    word-wrap: break-word;\n  }\n  .hljs-number, .hljs-hexcolor, .ruby .hljs-constant {\n    color: #888;\n  }\n  .hljs-string, .hljs-tag .hljs-value, .hljs-phpdoc, .hljs-dartdoc, .tex .hljs-formula {\n    color: #ddd;\n  }\n  .hljs-title, .hljs-id, .scss .hljs-preprocessor {\n    color: #999;\n  }\n  .hljs-class .hljs-title, .hljs-type, .vhdl .hljs-literal, .tex .hljs-command {\n    color: #888;\n  }\n  .hljs-tag, .hljs-tag .hljs-title, .hljs-rules .hljs-property, .django .hljs-tag .hljs-keyword {\n    color: #888;\n  }\n  .hljs-attribute, .hljs-variable, .lisp .hljs-body {\n    color: #888;\n  }\n  .hljs-regexp {\n    color: #999;\n  }\n  .hljs-symbol, .ruby .hljs-symbol .hljs-string, .lisp .hljs-keyword,\n  .clojure .hljs-keyword, .scheme .hljs-keyword, .tex .hljs-special,\n  .hljs-prompt {\n    color: #999;\n  }\n  .hljs-built_in {\n    color: #888;\n  }\n  .hljs-deletion {\n    background: #ddd;\n  }\n  .hljs-addition {\n    background: #ddd;\n  }\n  .diff .hljs-change {\n    background: #888;\n  }\n}",

"markover":"!(function() {\n\nvar markover = {\n\n\"title\":\"markover\",\n\n\"tag\":\"Web Literate Programming\",\n\n\"version\":\"0.0.1\",\n\n\"head\":\"<!DOCTYPE html>\\n<html lang=\\\"en\\\" class=\\\"\\\">\\n<head>\\n  <meta charset=\\\"utf-8\\\">\\n  <meta http-equiv=\\\"Content-Language\\\" content=\\\"en\\\">\\n  <meta name=\\\"viewport\\\" content=\\\"initial-scale=1\\\">\\n  <script type=\\\"text/x-mathjax-config\\\">\\n    MathJax.Hub.Config({\\n      showProcessingMessages: false,\\n      tex2jax: { inlineMath: [['\\\\\\\\(','\\\\\\\\)']] },\\n      TeX: { equationNumbers: {autoNumber: \\\"AMS\\\"} }\\n    });\\n  </script>\\n  <script type=\\\"text/javascript\\\"\\n    src=\\\"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\\\">\\n  </script>\\n  <script type=\\\"text/javascript\\\"\\n    src=\\\"http://code.jquery.com/jquery-2.1.3.min.js\\\">\\n  </script>\",\n\n\"transition\":\"</head>\\n<body>\",\n\n\"tail\":\"</body>\\n</html>\\n<script type=\\\"text/javascript\\\">\\n  [\\\"bash\\\", \\\"xml\\\", \\\"javascript\\\", \\\"json\\\", \\\"css\\\", \\\"markdown\\\"].forEach(function(e) {\\n    var s = $('<script>')\\n    s.type = 'text/javascript'\\n    s.src = 'http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/languages/' + e + '.min.js'\\n    $('head').append(s)\\n  })\\n</script>\",\n\n\"headstylesheet\":\"html, body, div, span, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre,\\nabbr, address, cite, code, del, dfn, em, img, ins, kbd, q, samp,\\nsmall, strong, sub, sup, var, b, i, dl, dt, dd, ol, ul, li, a,\\nfieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td,\\narticle, aside, canvas, details, figcaption, figure,\\nfooter, header, hgroup, menu, nav, section, summary, time, mark, audio, video {\\n  display: block;\\n  margin:0;\\n  padding:0;\\n  border:0;\\n  outline:0;\\n  line-height: 140%;\\n  font-size: 100%;\\n  vertical-align:baseline;\\n  text-decoration: none;\\n  background:transparent;\\n}\\n\\na, code, span, b, i, em { display: inline; }\",\n\n\"stylesheet\":\"#content {\\n  font-family: \\\"HelveticaNeue-Light\\\", \\\"Helvetica Neue Light\\\", \\\"Helvetica Neue\\\", Helvetica, Arial, \\\"Lucida Grande\\\", sans-serif; \\n}\\n\\n#content #title {\\n  clear: both;\\n  text-align: center;\\n  font-size: 140%;\\n  font-weight: bold;\\n  margin: 2em 0 0 0;\\n}\\n\\n#content #tag {\\n  clear: both;\\n  text-align: center;\\n  font-size: 110%;\\n  margin: 0 0 1em 0;\\n}\\n#content #toc {\\n  padding: 0 0 0 1em;\\n  max-width: 96%;\\n  page-break-after: always;\\n}\\n\\n@media screen and (min-width: 641px) {\\n  #content #toc {\\n    float: left;\\n    max-width: 26%;\\n  }\\n}\\n\\n#content .tocsn { float: left; }\\n#content .tocsr { overflow: hidden; }\\n\\n#content #toc ol {\\n  list-style-type: none;\\n}\\n\\n#content #toc ol ol {\\n  margin: 0 0 0 1em;\\n}\\n#content #doc,\\n#content #toc {\\n  margin: 0 1em 0 1em;\\n}\\n\\n#content p { text-indent: 1em; }\\n\\n#content code { font-size: 120%; }\\n\\n#content pre code {\\n  font-family: \\\"Courier New\\\", Courier, monospace;\\n  font-size: 100%;\\n}\\n\\n@media screen and (min-width: 641px) {\\n  #content #doc {\\n    overflow: hidden;\\n    max-width: 70%;\\n  }\\n}\\n#content pre .field {\\n  display:block;\\n  margin: 1em 1em 0em 0em;\\n}\\n\\n#content pre .field::after {\\n  content: \\\" :=\\\";\\n}\\n#content pre code {\\n  display: block;\\n  margin: 1em;\\n  padding: 1em;\\n  border: solid 1px #aaa;\\n}\\n\\n@media screen {\\n  #content pre code {\\n    overflow: auto;\\n    max-height: 30em;\\n  }\\n}\\n\\n@media print {\\n  #content pre {\\n    page-break-inside: avoid;\\n  }\\n  #content pre code {\\n    overflow: visible;\\n    word-wrap: break-word;\\n  }\\n}\\n@media screen {\\n  #content .lang-js { background-color: ivory; }\\n  #content .lang-md { background-color: lightyellow; }\\n  #content .lang-html { background-color: floralwhite; }\\n  #content .lang-json { background-color: honeydew; }\\n  #content .lang-css { background-color: cornsilk; }\\n  #content .lang-sh { background-color: lemonchiffon; }\\n}\\n#content h1,\\n#content h2,\\n#content h3,\\n#content h4,\\n#content h5,\\n#content h6 {\\n  margin: 0.5em 0em;\\n  page-break-after: avoid\\n}\\n\\n#content h1 { font-size: 140%; }\\n#content h2 { font-size: 130%; }\\n#content h3 { font-size: 120%; }\\n#content h4,\\n#content h5,\\n#content h6 { font-size: 110%; }\\n#content a:hover { color: #aaa; }\\n\\n#content a:visited,\\n#content a { color: #000;}\\n\\n@media screen {\\n  #content a {\\n    text-decoration: underline;\\n  }\\n}\\n@media print {\\n  #content a {\\n    text-decoration: none;\\n  }\\n  #content #doc a[href]:after {\\n    content: \\\" (\\\" attr(href) \\\")\\\";\\n    font-size: 90%;\\n  }\\n}\\n.hljs {\\n    overflow: auto;\\n    padding: 0.5em;\\n    color: #333;\\n}\\n.hljs-comment, .diff .hljs-header, .hljs-javadoc {\\n    color: #999;\\n    font-style: italic;\\n}\\n.hljs-keyword, .css .rule .hljs-keyword, .hljs-winutils, .nginx .hljs-title,\\n.hljs-subst, .hljs-request, .hljs-status {\\n    color: #333;\\n    font-weight: bold;\\n}\\n.hljs-number, .hljs-hexcolor, .ruby .hljs-constant {\\n    color: #088;\\n}\\n.hljs-string, .hljs-tag .hljs-value, .hljs-phpdoc, .hljs-dartdoc, .tex .hljs-formula {\\n    color: #d14;\\n}\\n.hljs-title, .hljs-id, .scss .hljs-preprocessor {\\n    color: #900;\\n    font-weight: bold;\\n}\\n.hljs-list .hljs-keyword, .hljs-subst {\\n    font-weight: normal;\\n}\\n.hljs-class .hljs-title, .hljs-type, .vhdl .hljs-literal, .tex .hljs-command {\\n    color: #458;\\n    font-weight: bold;\\n}\\n.hljs-tag, .hljs-tag .hljs-title, .hljs-rules .hljs-property, .django .hljs-tag .hljs-keyword {\\n    color: #000080;\\n    font-weight: normal;\\n}\\n.hljs-attribute, .hljs-variable, .lisp .hljs-body {\\n    color: #008080;\\n}\\n.hljs-regexp {\\n    color: #009926;\\n}\\n.hljs-built_in {\\n    color: #0086b3;\\n}\\n\\n.hljs-symbol, .ruby .hljs-symbol .hljs-string, .lisp .hljs-keyword,\\n.clojure .hljs-keyword, .scheme .hljs-keyword, .tex .hljs-special,\\n.hljs-prompt {\\n    color: #990073;\\n}\\n.hljs-preprocessor, .hljs-pragma, .hljs-pi, .hljs-doctype, .hljs-shebang,\\n.hljs-cdata {\\n    color: #999;\\n    font-weight: bold;\\n}\\n.hljs-deletion {\\n    background: #fdd;\\n}\\n.hljs-addition {\\n    background: #dfd;\\n}\\n.diff .hljs-change {\\n    background: #0086b3;\\n}\\n.hljs-chunk {\\n    color: #aaa;\\n}\\n@media print {\\n  .hljs {\\n    overflow: visible;\\n    word-wrap: break-word;\\n  }\\n  .hljs-number, .hljs-hexcolor, .ruby .hljs-constant {\\n    color: #888;\\n  }\\n  .hljs-string, .hljs-tag .hljs-value, .hljs-phpdoc, .hljs-dartdoc, .tex .hljs-formula {\\n    color: #ddd;\\n  }\\n  .hljs-title, .hljs-id, .scss .hljs-preprocessor {\\n    color: #999;\\n  }\\n  .hljs-class .hljs-title, .hljs-type, .vhdl .hljs-literal, .tex .hljs-command {\\n    color: #888;\\n  }\\n  .hljs-tag, .hljs-tag .hljs-title, .hljs-rules .hljs-property, .django .hljs-tag .hljs-keyword {\\n    color: #888;\\n  }\\n  .hljs-attribute, .hljs-variable, .lisp .hljs-body {\\n    color: #888;\\n  }\\n  .hljs-regexp {\\n    color: #999;\\n  }\\n  .hljs-symbol, .ruby .hljs-symbol .hljs-string, .lisp .hljs-keyword,\\n  .clojure .hljs-keyword, .scheme .hljs-keyword, .tex .hljs-special,\\n  .hljs-prompt {\\n    color: #999;\\n  }\\n  .hljs-built_in {\\n    color: #888;\\n  }\\n  .hljs-deletion {\\n    background: #ddd;\\n  }\\n  .hljs-addition {\\n    background: #ddd;\\n  }\\n  .diff .hljs-change {\\n    background: #888;\\n  }\\n}\",\n\n\"pool\":function(options) {\n  options = options || {}\n\n  var dam = new require('stream').Transform()\n  dam.options = options\n  dam.options.convert = dam.options.convert || function(string, options) { return string }\n  dam.options.self = dam.options.self || this\n\n  dam.lake = []\n  dam._transform = function(chunk, encoding, done) {\n    dam.lake.push(chunk.toString())\n    done()\n  }\n\n  dam._flush = function(done) {\n    dam.push(dam.options.convert.call(dam.options.self, dam.lake.join(''), dam.options))\n    dam.push('\\n')\n    dam.lake = []\n    done()\n  }\n\n  return dam\n},\n\n\"escape\":function (html, encode) {\n  return html\n    .replace(!encode ? /&(?!#?\\w+;)/g : /&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;');\n},\n\n\"unescape\":function(html) {\n  return html.replace(/&([#\\w]+);/g, function(_, n) {\n    n = n.toLowerCase();\n    if (n === 'colon') return ':';\n    if (n === 'lt') return '<';\n    if (n === 'gt') return '>';\n    if (n === 'quot') return '\"';\n    if (n.charAt(0) === '#') {\n      return n.charAt(1) === 'x'\n        ? String.fromCharCode(parseInt(n.substring(2), 16))\n        : String.fromCharCode(+n.substring(1));\n    }\n    return '';\n  })\n},\n\n\"tangleFormatPrefix\":\" {%n%n\",\n\n\"tangleFormatSuffix\":\"%n}%n%n\",\n\n\"tangleFormatDelimiter\":\",%n%n\",\n\n\"tangleFormatFieldPrefix\":\"\\\"\",\n\n\"tangleFormatFieldSuffix\":\"\\\":\",\n\n\"tangleFormat\":function(ff, fields, lf) {\n  var res = [ff, this.tangleFormatPrefix]\n  var firsttime = true\n  var v\n  for (var e in fields) {\n    v = fields[e]\n    if (firsttime) {\n      firsttime = false\n    } else {\n      res.push(this.tangleFormatDelimiter)\n    }\n    res.push(this.tangleFormatFieldPrefix + e + this.tangleFormatFieldSuffix)\n    res.push(v)\n  }\n   res.push(this.tangleFormatSuffix)\n   res.push(lf)\n\n   return res.join('')\n     .replace(/%q/gm, '\\\"')\n     .replace(/%n/gm, '\\n')\n     .replace(/%t/gm, '\\t')\n     .replace(/%s/gm, '\\\\')\n     .replace(/%p/gm , '%')\n},\n\n\"tangleJSON\":function (str, options) {\n  options = options || {}\n  options.exclude = options.exclude || []\n  var marked = require('marked')\n  var p = new marked.Renderer()\n  marked.setOptions({\n    renderer: p,\n    gfm: true,\n    tables: true,\n    breaks: false,\n    pedantic: false,\n    sanitize: true,\n    smartLists: true,\n    smartypants: false\n  })\n  p.code = function(code, lang, escaped) {\n\n    if (!lang)\n      return ''\n\n    var field = lang.replace(/\\S*#[+]?(\\S*)/, \"$1\")\n    if (lang == field)\n      return ''\n\n    var quote = lang.replace(/\\S*#([+]?)\\S*/, \"$1\")\n    lang = lang.replace(/(\\S*)#[+]?\\S*/, \"$1\")\n    if (lang == '') lang = 'json'\n\n    if (quote == '+') {\n      code = ('\"' +\n        code\n          .replace(/\\\\/gm, '\\\\\\\\')\n          .replace(/\\\"/gm /*\"*/, '\\\\\"')\n          .replace(/\\n/gm , '\\\\n')\n          .replace(/\\t/gm , '\\\\t')\n        + '\"')\n    }\n\n    var esccode = code\n      .replace(/%/gm , '%p')\n      .replace(/\"/gm /*\"*/, '%q')\n      .replace(/\\n/gm, '%n')\n      .replace(/\\t/gm, '%t')\n      .replace(/\\\\/gm, '%s')\n\n    return ',[\"' + field + '\", \"' + (quote == '+')  + '\", \"' + esccode + '\"]'\n  }\n  function noop() { return ''}\n\n  p.blockquote = noop\n  p.html = noop\n  p.heading = noop\n  p.hr = noop\n  p.list = noop\n  p.listitem = noop\n  p.paragraph = noop\n  p.table = noop\n  p.tablerow = noop\n  p.tablecell = noop\n  p.strong = noop\n  p.em = noop\n  p.codespan = noop\n  p.br = noop\n  p.del = noop\n  p.link = noop\n  p.image = noop\n  var doc = '[' + marked(str).substring(1) + ']'\n  var obj = JSON.parse(doc)\n  var fields = {}\n  var ff = ''\n  var lf = ''\n  var res = obj.forEach(function(e) {\n    var k = e[0]\n    var q = (e[1] == \"true\")\n    var v = e[2]\n    var doit = true\n    if (options.exclude.indexOf(k) != -1)\n      doit = false\n    if (doit) {\n      if (fields[k] != undefined) {\n        if (q) {\n          v = fields[k].substring(0,fields[k].length-2) + '\\\\n' + v.substring(2)\n        } else {\n          v = fields[k] + '%n' + v\n        }\n      }\n      fields[k] = v\n    }\n  })\n  if (fields[\"first\"] != undefined) {\n    ff = fields[\"first\"]\n    delete fields[\"first\"]\n  }\n\n  if (fields[\"last\"] != undefined) {\n    lf = fields[\"last\"]\n    delete fields[\"last\"]\n  }\n\n  if (options.sourcetarget) {\n    fields[options.sourcetarget] = \n        ('\"' +\n          str\n          .replace(/\\\\/gm, '\\\\\\\\')\n          .replace(/\\\"/gm /*\"*/, '\\\\\"')\n          .replace(/\\n/gm , '\\\\n')\n          .replace(/\\t/gm , '\\\\t')\n          .replace(/%/gm , '%p')\n        + '\"')\n  }\n\n  return this.tangleFormat(ff, fields, lf)\n},\n\n\"tangleStream\":function (opts) {\n  var options = {convert: this.tangleJSON, self:this}\n  for(var i in opts)\n    options[i] = opts[i]\n  var p = this.pool(options)\n\n  if (!p.options.notstdio) {\n    process.stdin.pipe(p).pipe(process.stdout)\n    return true\n  }\n\n  return p\n},\n\n\"heading\":function(text, level, raw, toc, prefix) {\n  var i = raw.toLowerCase().replace(/[^\\w]+/g, '-')\n  var n = [0, 0, 0, 0, 0, 0, 0]\n  if (level > 6) level = 6\n  else if (level < 1) level = 1\n  toc.push([text, level, i])\n  var l\n  for (var x = 0; x < toc.length; x++) {\n    l = toc[x][1]\n    n[l] = n[l] + 1\n    while (++l < toc.length)\n      n[l] = 0\n  }\n  var sn = n.slice(1, level+1).join('.') + (level == 1 ? '.' : '')\n  toc[toc.length-1].push(sn)\n  return '<h'\n    + level\n    + ' id=\"'\n    + prefix\n    + i\n    + '\">'\n    + sn + ' ' + text\n    + '</h'\n    + level\n    + '>\\n'\n},\n\n\"weaveHighlight\":function (lang, code) {\n  var hljs = require('highlight.js')\n  code = hljs.highlight(lang, this.unescape(code), true)\n  return code\n},\n\n\"weaveCode\":function(code, lang, escaped, fields, prefix) {\n  var c = code\n  if (!lang) {\n    return '<pre><code>'\n      + this.escape(c)\n      + '\\n</code></pre>'\n  }\n  var i = lang.indexOf('#')\n  if (i == -1) {\n    if (lang == \"noweave\") return ''\n    return '<pre><code class=\"'\n      + prefix\n      + this.escape(lang, true)\n      + '\">'\n      + this.weaveHighlight(lang, c).value\n      + '\\n</code></pre>\\n'\n  }\n  var field = lang.substring(i+1)\n  lang = lang.substring(0, i)\n  if (lang == \"\") lang = \"json\"\n\n  if (field.substring(0,1) == '+') {\n    field = field.substring(1)\n  }\n\n  if (fields[field] == undefined) {\n    fields[field] = c\n  } else {\n    fields[field] = fields[field] + '\\n' + c\n  }\n\n  if (lang == \"noweave\") return ''\n\n  return '<pre><div class=\"field\">'\n    + field + '</div>'\n    + '<code class=\"'\n    + prefix\n    + this.escape(lang, true)\n    + '\">'\n    + this.weaveHighlight((lang != \"\" ? lang : \"json\"), c).value\n    + '\\n</code></pre>\\n'\n},\n\n\"weaveMarked\":function () {\n  var marked = require('marked')\n  var p = new marked.Renderer()\n\n  marked.setOptions({\n    renderer: p,\n    gfm: true,\n    tables: true,\n    breaks: false,\n    pedantic: false,\n    sanitize: true,\n    smartLists: true,\n    smartypants: false\n  })\n  p.field = []\n  p.toc = []\n  p.self = this\n  p.heading = function (text, level, raw) {\n    return this.self.heading.call(this.self, text, level, raw, p.toc, this.options.headerPrefix)\n  }\n  p.code = function (code, lang, escaped) {\n    return this.self.weaveCode.call(this.self, code, lang, escaped, p.field, this.options.langPrefix)\n  }\n\n  return [marked, p]\n},\n\n\"weaveJSON\":function (str, options) {\n  options = options || {}\n  var m = this.weaveMarked()\n  var marked = m[0]\n  var p = m[1]\n  var doc = marked.call(this, str)\n  function f(l,d) { return this.unescape(p.field[l] || d) }\n  var title = f(\"title\", \"Weave Output\")\n  var tag = f(\"tag\", \"from weaving\")\n  var headstylesheet = f(\"headstylesheet\", \"\")\n  var stylesheet = f(\"stylesheet\", \"\")\n\n  var headline = f(\"head\", \"<!DOCTYPE html><html><head>\")\n  var transitionline = f(\"transition\", \"</head><body>\")\n  var tailline = f(\"tail\", \"</body></html>\") + '\\n'\n\n  var headtitle = '<title>' + title + ' - ' + tag + '</title>\\n'\n  var titleline = '<div id=\"title\">' + title + '</div>'\n  var tagline = '<div id=\"tag\">' + tag + '</div>'\n\n  var headstyleline = headstylesheet == '' ? '' : '<style>' + headstylesheet + '</style>'\n  var styleline = stylesheet == '' ? '' : '<style>' + stylesheet + '</style>'\n  var tocitems = p.toc.map(function(e, i, a) {\n    var ll = 0\n    var o = ''\n    if (i > 0) ll = a[i-1][1]\n    if (ll < e[1]) {\n      while (ll++ < e[1])\n        o = o + '<ol>'\n    } else if (ll > e[1]) {\n      while (ll-- > e[1])\n        o = o + '</ol>'\n    }\n    return (\n            o + '<li><div class=\"tocsn\">' + e[3] + '&nbsp;</div><div class=\"tocsr\"><a href=\"#' + e[2] + '\">'\n          + e[0] + '</a></div>'\n           )\n  })\n  var toc = ''\n  var ll\n  var o\n\n  if (p.toc.length > 0) {\n    ll = p.toc[p.toc.length-1][1]\n    o = ''\n    while (ll-- > 0)\n      o = o + '</ol>'\n    toc = '<div id=\"toc\"><h1>Contents</h1>\\n' + tocitems.join('\\n') + o + '</div>\\n'\n  }\n  var heading = ''\n  var tailing = ''\n  if (options.contentonly != true) {\n    heading = headline + headtitle + headstyleline + styleline + transitionline\n    tailing = tailline\n  } else\n    heading = styleline\n\n  return (heading +\n          '<div id=\"content\">' +\n             titleline + tagline + toc +\n          '<div id=\"doc\">' + doc + '</div>' +\n          '</div>' + tailing)\n},\n\n\"weaveStream\":function (opts) {\n  var options = {convert: this.weaveJSON, self:this}\n  for(var i in opts)\n    options[i] = opts[i]\n  var p = this.pool(options)\n\n  if (!p.options.notstdio) {\n    process.stdin.pipe(p).pipe(process.stdout)\n    return true\n  }\n\n  return p\n},\n\n\"untangleStream\":function (opts) {\n  opts = opts || {}\n  var options\n  options = {\n    convert: function (str, options) {\n      return '```\\n' + str + '```\\n'\n    },\n    self: this\n  }\n\n  for(var i in opts)\n    options[i] = opts[i]\n\n  var p = this.pool(options)\n\n  if (!options.notstdio) {\n    process.stdin.pipe(p).pipe(process.stdout)\n    return true\n  }\n\n  return p\n}\n}\n\nif (typeof module !== 'undefined' && typeof exports === 'object') {\n    module.exports = markover\n} else if (typeof define === 'function' && define.amd) {\n    define(function() { return markover })\n} else {\n    this.markover = markover\n}\n\n}).call(function () {\n        return this || (typeof window !== 'undefined' ? window : global)\n})",

"marked":"/**\n * marked - a markdown parser\n * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/chjj/marked\n */\n\n;(function() {\n\n/**\n * Block-Level Grammar\n */\n\nvar block = {\n  newline: /^\\n+/,\n  code: /^( {4}[^\\n]+\\n*)+/,\n  fences: noop,\n  hr: /^( *[-*_]){3,} *(?:\\n+|$)/,\n  heading: /^ *(#{1,6}) *([^\\n]+?) *#* *(?:\\n+|$)/,\n  nptable: noop,\n  lheading: /^([^\\n]+)\\n *(=|-){2,} *(?:\\n+|$)/,\n  blockquote: /^( *>[^\\n]+(\\n(?!def)[^\\n]+)*\\n*)+/,\n  list: /^( *)(bull) [\\s\\S]+?(?:hr|def|\\n{2,}(?! )(?!\\1bull )\\n*|\\s*$)/,\n  html: /^ *(?:comment|closed|closing) *(?:\\n{2,}|\\s*$)/,\n  def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +[\"(]([^\\n]+)[\")])? *(?:\\n+|$)/,\n  table: noop,\n  paragraph: /^((?:[^\\n]+\\n?(?!hr|heading|lheading|blockquote|tag|def))+)\\n*/,\n  text: /^[^\\n]+/\n};\n\nblock.bullet = /(?:[*+-]|\\d+\\.)/;\nblock.item = /^( *)(bull) [^\\n]*(?:\\n(?!\\1bull )[^\\n]*)*/;\nblock.item = replace(block.item, 'gm')\n  (/bull/g, block.bullet)\n  ();\n\nblock.list = replace(block.list)\n  (/bull/g, block.bullet)\n  ('hr', '\\\\n+(?=\\\\1?(?:[-*_] *){3,}(?:\\\\n+|$))')\n  ('def', '\\\\n+(?=' + block.def.source + ')')\n  ();\n\nblock.blockquote = replace(block.blockquote)\n  ('def', block.def)\n  ();\n\nblock._tag = '(?!(?:'\n  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'\n  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'\n  + '|span|br|wbr|ins|del|img)\\\\b)\\\\w+(?!:/|[^\\\\w\\\\s@]*@)\\\\b';\n\nblock.html = replace(block.html)\n  ('comment', /<!--[\\s\\S]*?-->/)\n  ('closed', /<(tag)[\\s\\S]+?<\\/\\1>/)\n  ('closing', /<tag(?:\"[^\"]*\"|'[^']*'|[^'\">])*?>/)\n  (/tag/g, block._tag)\n  ();\n\nblock.paragraph = replace(block.paragraph)\n  ('hr', block.hr)\n  ('heading', block.heading)\n  ('lheading', block.lheading)\n  ('blockquote', block.blockquote)\n  ('tag', '<' + block._tag)\n  ('def', block.def)\n  ();\n\n/**\n * Normal Block Grammar\n */\n\nblock.normal = merge({}, block);\n\n/**\n * GFM Block Grammar\n */\n\nblock.gfm = merge({}, block.normal, {\n  fences: /^ *(`{3,}|~{3,}) *(\\S+)? *\\n([\\s\\S]+?)\\s*\\1 *(?:\\n+|$)/,\n  paragraph: /^/\n});\n\nblock.gfm.paragraph = replace(block.paragraph)\n  ('(?!', '(?!'\n    + block.gfm.fences.source.replace('\\\\1', '\\\\2') + '|'\n    + block.list.source.replace('\\\\1', '\\\\3') + '|')\n  ();\n\n/**\n * GFM + Tables Block Grammar\n */\n\nblock.tables = merge({}, block.gfm, {\n  nptable: /^ *(\\S.*\\|.*)\\n *([-:]+ *\\|[-| :]*)\\n((?:.*\\|.*(?:\\n|$))*)\\n*/,\n  table: /^ *\\|(.+)\\n *\\|( *[-:]+[-| :]*)\\n((?: *\\|.*(?:\\n|$))*)\\n*/\n});\n\n/**\n * Block Lexer\n */\n\nfunction Lexer(options) {\n  this.tokens = [];\n  this.tokens.links = {};\n  this.options = options || marked.defaults;\n  this.rules = block.normal;\n\n  if (this.options.gfm) {\n    if (this.options.tables) {\n      this.rules = block.tables;\n    } else {\n      this.rules = block.gfm;\n    }\n  }\n}\n\n/**\n * Expose Block Rules\n */\n\nLexer.rules = block;\n\n/**\n * Static Lex Method\n */\n\nLexer.lex = function(src, options) {\n  var lexer = new Lexer(options);\n  return lexer.lex(src);\n};\n\n/**\n * Preprocessing\n */\n\nLexer.prototype.lex = function(src) {\n  src = src\n    .replace(/\\r\\n|\\r/g, '\\n')\n    .replace(/\\t/g, '    ')\n    .replace(/\\u00a0/g, ' ')\n    .replace(/\\u2424/g, '\\n');\n\n  return this.token(src, true);\n};\n\n/**\n * Lexing\n */\n\nLexer.prototype.token = function(src, top, bq) {\n  var src = src.replace(/^ +$/gm, '')\n    , next\n    , loose\n    , cap\n    , bull\n    , b\n    , item\n    , space\n    , i\n    , l;\n\n  while (src) {\n    // newline\n    if (cap = this.rules.newline.exec(src)) {\n      src = src.substring(cap[0].length);\n      if (cap[0].length > 1) {\n        this.tokens.push({\n          type: 'space'\n        });\n      }\n    }\n\n    // code\n    if (cap = this.rules.code.exec(src)) {\n      src = src.substring(cap[0].length);\n      cap = cap[0].replace(/^ {4}/gm, '');\n      this.tokens.push({\n        type: 'code',\n        text: !this.options.pedantic\n          ? cap.replace(/\\n+$/, '')\n          : cap\n      });\n      continue;\n    }\n\n    // fences (gfm)\n    if (cap = this.rules.fences.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'code',\n        lang: cap[2],\n        text: cap[3]\n      });\n      continue;\n    }\n\n    // heading\n    if (cap = this.rules.heading.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'heading',\n        depth: cap[1].length,\n        text: cap[2]\n      });\n      continue;\n    }\n\n    // table no leading pipe (gfm)\n    if (top && (cap = this.rules.nptable.exec(src))) {\n      src = src.substring(cap[0].length);\n\n      item = {\n        type: 'table',\n        header: cap[1].replace(/^ *| *\\| *$/g, '').split(/ *\\| */),\n        align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n        cells: cap[3].replace(/\\n$/, '').split('\\n')\n      };\n\n      for (i = 0; i < item.align.length; i++) {\n        if (/^ *-+: *$/.test(item.align[i])) {\n          item.align[i] = 'right';\n        } else if (/^ *:-+: *$/.test(item.align[i])) {\n          item.align[i] = 'center';\n        } else if (/^ *:-+ *$/.test(item.align[i])) {\n          item.align[i] = 'left';\n        } else {\n          item.align[i] = null;\n        }\n      }\n\n      for (i = 0; i < item.cells.length; i++) {\n        item.cells[i] = item.cells[i].split(/ *\\| */);\n      }\n\n      this.tokens.push(item);\n\n      continue;\n    }\n\n    // lheading\n    if (cap = this.rules.lheading.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'heading',\n        depth: cap[2] === '=' ? 1 : 2,\n        text: cap[1]\n      });\n      continue;\n    }\n\n    // hr\n    if (cap = this.rules.hr.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'hr'\n      });\n      continue;\n    }\n\n    // blockquote\n    if (cap = this.rules.blockquote.exec(src)) {\n      src = src.substring(cap[0].length);\n\n      this.tokens.push({\n        type: 'blockquote_start'\n      });\n\n      cap = cap[0].replace(/^ *> ?/gm, '');\n\n      // Pass `top` to keep the current\n      // \"toplevel\" state. This is exactly\n      // how markdown.pl works.\n      this.token(cap, top, true);\n\n      this.tokens.push({\n        type: 'blockquote_end'\n      });\n\n      continue;\n    }\n\n    // list\n    if (cap = this.rules.list.exec(src)) {\n      src = src.substring(cap[0].length);\n      bull = cap[2];\n\n      this.tokens.push({\n        type: 'list_start',\n        ordered: bull.length > 1\n      });\n\n      // Get each top-level item.\n      cap = cap[0].match(this.rules.item);\n\n      next = false;\n      l = cap.length;\n      i = 0;\n\n      for (; i < l; i++) {\n        item = cap[i];\n\n        // Remove the list item's bullet\n        // so it is seen as the next token.\n        space = item.length;\n        item = item.replace(/^ *([*+-]|\\d+\\.) +/, '');\n\n        // Outdent whatever the\n        // list item contains. Hacky.\n        if (~item.indexOf('\\n ')) {\n          space -= item.length;\n          item = !this.options.pedantic\n            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')\n            : item.replace(/^ {1,4}/gm, '');\n        }\n\n        // Determine whether the next list item belongs here.\n        // Backpedal if it does not belong in this list.\n        if (this.options.smartLists && i !== l - 1) {\n          b = block.bullet.exec(cap[i + 1])[0];\n          if (bull !== b && !(bull.length > 1 && b.length > 1)) {\n            src = cap.slice(i + 1).join('\\n') + src;\n            i = l - 1;\n          }\n        }\n\n        // Determine whether item is loose or not.\n        // Use: /(^|\\n)(?! )[^\\n]+\\n\\n(?!\\s*$)/\n        // for discount behavior.\n        loose = next || /\\n\\n(?!\\s*$)/.test(item);\n        if (i !== l - 1) {\n          next = item.charAt(item.length - 1) === '\\n';\n          if (!loose) loose = next;\n        }\n\n        this.tokens.push({\n          type: loose\n            ? 'loose_item_start'\n            : 'list_item_start'\n        });\n\n        // Recurse.\n        this.token(item, false, bq);\n\n        this.tokens.push({\n          type: 'list_item_end'\n        });\n      }\n\n      this.tokens.push({\n        type: 'list_end'\n      });\n\n      continue;\n    }\n\n    // html\n    if (cap = this.rules.html.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: this.options.sanitize\n          ? 'paragraph'\n          : 'html',\n        pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',\n        text: cap[0]\n      });\n      continue;\n    }\n\n    // def\n    if ((!bq && top) && (cap = this.rules.def.exec(src))) {\n      src = src.substring(cap[0].length);\n      this.tokens.links[cap[1].toLowerCase()] = {\n        href: cap[2],\n        title: cap[3]\n      };\n      continue;\n    }\n\n    // table (gfm)\n    if (top && (cap = this.rules.table.exec(src))) {\n      src = src.substring(cap[0].length);\n\n      item = {\n        type: 'table',\n        header: cap[1].replace(/^ *| *\\| *$/g, '').split(/ *\\| */),\n        align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n        cells: cap[3].replace(/(?: *\\| *)?\\n$/, '').split('\\n')\n      };\n\n      for (i = 0; i < item.align.length; i++) {\n        if (/^ *-+: *$/.test(item.align[i])) {\n          item.align[i] = 'right';\n        } else if (/^ *:-+: *$/.test(item.align[i])) {\n          item.align[i] = 'center';\n        } else if (/^ *:-+ *$/.test(item.align[i])) {\n          item.align[i] = 'left';\n        } else {\n          item.align[i] = null;\n        }\n      }\n\n      for (i = 0; i < item.cells.length; i++) {\n        item.cells[i] = item.cells[i]\n          .replace(/^ *\\| *| *\\| *$/g, '')\n          .split(/ *\\| */);\n      }\n\n      this.tokens.push(item);\n\n      continue;\n    }\n\n    // top-level paragraph\n    if (top && (cap = this.rules.paragraph.exec(src))) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'paragraph',\n        text: cap[1].charAt(cap[1].length - 1) === '\\n'\n          ? cap[1].slice(0, -1)\n          : cap[1]\n      });\n      continue;\n    }\n\n    // text\n    if (cap = this.rules.text.exec(src)) {\n      // Top-level should never reach here.\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'text',\n        text: cap[0]\n      });\n      continue;\n    }\n\n    if (src) {\n      throw new\n        Error('Infinite loop on byte: ' + src.charCodeAt(0));\n    }\n  }\n\n  return this.tokens;\n};\n\n/**\n * Inline-Level Grammar\n */\n\nvar inline = {\n  escape: /^\\\\([\\\\`*{}\\[\\]()#+\\-.!_>])/,\n  autolink: /^<([^ >]+(@|:\\/)[^ >]+)>/,\n  url: noop,\n  tag: /^<!--[\\s\\S]*?-->|^<\\/?\\w+(?:\"[^\"]*\"|'[^']*'|[^'\">])*?>/,\n  link: /^!?\\[(inside)\\]\\(href\\)/,\n  reflink: /^!?\\[(inside)\\]\\s*\\[([^\\]]*)\\]/,\n  nolink: /^!?\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\]/,\n  strong: /^__([\\s\\S]+?)__(?!_)|^\\*\\*([\\s\\S]+?)\\*\\*(?!\\*)/,\n  em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n  code: /^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/,\n  br: /^ {2,}\\n(?!\\s*$)/,\n  del: noop,\n  text: /^[\\s\\S]+?(?=[\\\\<!\\[_*`]| {2,}\\n|$)/\n};\n\ninline._inside = /(?:\\[[^\\]]*\\]|[^\\[\\]]|\\](?=[^\\[]*\\]))*/;\ninline._href = /\\s*<?([\\s\\S]*?)>?(?:\\s+['\"]([\\s\\S]*?)['\"])?\\s*/;\n\ninline.link = replace(inline.link)\n  ('inside', inline._inside)\n  ('href', inline._href)\n  ();\n\ninline.reflink = replace(inline.reflink)\n  ('inside', inline._inside)\n  ();\n\n/**\n * Normal Inline Grammar\n */\n\ninline.normal = merge({}, inline);\n\n/**\n * Pedantic Inline Grammar\n */\n\ninline.pedantic = merge({}, inline.normal, {\n  strong: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\n  em: /^_(?=\\S)([\\s\\S]*?\\S)_(?!_)|^\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)/\n});\n\n/**\n * GFM Inline Grammar\n */\n\ninline.gfm = merge({}, inline.normal, {\n  escape: replace(inline.escape)('])', '~|])')(),\n  url: /^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/,\n  del: /^~~(?=\\S)([\\s\\S]*?\\S)~~/,\n  text: replace(inline.text)\n    (']|', '~]|')\n    ('|', '|https?://|')\n    ()\n});\n\n/**\n * GFM + Line Breaks Inline Grammar\n */\n\ninline.breaks = merge({}, inline.gfm, {\n  br: replace(inline.br)('{2,}', '*')(),\n  text: replace(inline.gfm.text)('{2,}', '*')()\n});\n\n/**\n * Inline Lexer & Compiler\n */\n\nfunction InlineLexer(links, options) {\n  this.options = options || marked.defaults;\n  this.links = links;\n  this.rules = inline.normal;\n  this.renderer = this.options.renderer || new Renderer;\n  this.renderer.options = this.options;\n\n  if (!this.links) {\n    throw new\n      Error('Tokens array requires a `links` property.');\n  }\n\n  if (this.options.gfm) {\n    if (this.options.breaks) {\n      this.rules = inline.breaks;\n    } else {\n      this.rules = inline.gfm;\n    }\n  } else if (this.options.pedantic) {\n    this.rules = inline.pedantic;\n  }\n}\n\n/**\n * Expose Inline Rules\n */\n\nInlineLexer.rules = inline;\n\n/**\n * Static Lexing/Compiling Method\n */\n\nInlineLexer.output = function(src, links, options) {\n  var inline = new InlineLexer(links, options);\n  return inline.output(src);\n};\n\n/**\n * Lexing/Compiling\n */\n\nInlineLexer.prototype.output = function(src) {\n  var out = ''\n    , link\n    , text\n    , href\n    , cap;\n\n  while (src) {\n    // escape\n    if (cap = this.rules.escape.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += cap[1];\n      continue;\n    }\n\n    // autolink\n    if (cap = this.rules.autolink.exec(src)) {\n      src = src.substring(cap[0].length);\n      if (cap[2] === '@') {\n        text = cap[1].charAt(6) === ':'\n          ? this.mangle(cap[1].substring(7))\n          : this.mangle(cap[1]);\n        href = this.mangle('mailto:') + text;\n      } else {\n        text = escape(cap[1]);\n        href = text;\n      }\n      out += this.renderer.link(href, null, text);\n      continue;\n    }\n\n    // url (gfm)\n    if (!this.inLink && (cap = this.rules.url.exec(src))) {\n      src = src.substring(cap[0].length);\n      text = escape(cap[1]);\n      href = text;\n      out += this.renderer.link(href, null, text);\n      continue;\n    }\n\n    // tag\n    if (cap = this.rules.tag.exec(src)) {\n      if (!this.inLink && /^<a /i.test(cap[0])) {\n        this.inLink = true;\n      } else if (this.inLink && /^<\\/a>/i.test(cap[0])) {\n        this.inLink = false;\n      }\n      src = src.substring(cap[0].length);\n      out += this.options.sanitize\n        ? escape(cap[0])\n        : cap[0];\n      continue;\n    }\n\n    // link\n    if (cap = this.rules.link.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.inLink = true;\n      out += this.outputLink(cap, {\n        href: cap[2],\n        title: cap[3]\n      });\n      this.inLink = false;\n      continue;\n    }\n\n    // reflink, nolink\n    if ((cap = this.rules.reflink.exec(src))\n        || (cap = this.rules.nolink.exec(src))) {\n      src = src.substring(cap[0].length);\n      link = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n      link = this.links[link.toLowerCase()];\n      if (!link || !link.href) {\n        out += cap[0].charAt(0);\n        src = cap[0].substring(1) + src;\n        continue;\n      }\n      this.inLink = true;\n      out += this.outputLink(cap, link);\n      this.inLink = false;\n      continue;\n    }\n\n    // strong\n    if (cap = this.rules.strong.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.renderer.strong(this.output(cap[2] || cap[1]));\n      continue;\n    }\n\n    // em\n    if (cap = this.rules.em.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.renderer.em(this.output(cap[2] || cap[1]));\n      continue;\n    }\n\n    // code\n    if (cap = this.rules.code.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.renderer.codespan(escape(cap[2], true));\n      continue;\n    }\n\n    // br\n    if (cap = this.rules.br.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.renderer.br();\n      continue;\n    }\n\n    // del (gfm)\n    if (cap = this.rules.del.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.renderer.del(this.output(cap[1]));\n      continue;\n    }\n\n    // text\n    if (cap = this.rules.text.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += escape(this.smartypants(cap[0]));\n      continue;\n    }\n\n    if (src) {\n      throw new\n        Error('Infinite loop on byte: ' + src.charCodeAt(0));\n    }\n  }\n\n  return out;\n};\n\n/**\n * Compile Link\n */\n\nInlineLexer.prototype.outputLink = function(cap, link) {\n  var href = escape(link.href)\n    , title = link.title ? escape(link.title) : null;\n\n  return cap[0].charAt(0) !== '!'\n    ? this.renderer.link(href, title, this.output(cap[1]))\n    : this.renderer.image(href, title, escape(cap[1]));\n};\n\n/**\n * Smartypants Transformations\n */\n\nInlineLexer.prototype.smartypants = function(text) {\n  if (!this.options.smartypants) return text;\n  return text\n    // em-dashes\n    .replace(/--/g, '\\u2014')\n    // opening singles\n    .replace(/(^|[-\\u2014/(\\[{\"\\s])'/g, '$1\\u2018')\n    // closing singles & apostrophes\n    .replace(/'/g, '\\u2019')\n    // opening doubles\n    .replace(/(^|[-\\u2014/(\\[{\\u2018\\s])\"/g, '$1\\u201c')\n    // closing doubles\n    .replace(/\"/g, '\\u201d')\n    // ellipses\n    .replace(/\\.{3}/g, '\\u2026');\n};\n\n/**\n * Mangle Links\n */\n\nInlineLexer.prototype.mangle = function(text) {\n  var out = ''\n    , l = text.length\n    , i = 0\n    , ch;\n\n  for (; i < l; i++) {\n    ch = text.charCodeAt(i);\n    if (Math.random() > 0.5) {\n      ch = 'x' + ch.toString(16);\n    }\n    out += '&#' + ch + ';';\n  }\n\n  return out;\n};\n\n/**\n * Renderer\n */\n\nfunction Renderer(options) {\n  this.options = options || {};\n}\n\nRenderer.prototype.code = function(code, lang, escaped) {\n  if (this.options.highlight) {\n    var out = this.options.highlight(code, lang);\n    if (out != null && out !== code) {\n      escaped = true;\n      code = out;\n    }\n  }\n\n  if (!lang) {\n    return '<pre><code>'\n      + (escaped ? code : escape(code, true))\n      + '\\n</code></pre>';\n  }\n\n  return '<pre><code class=\"'\n    + this.options.langPrefix\n    + escape(lang, true)\n    + '\">'\n    + (escaped ? code : escape(code, true))\n    + '\\n</code></pre>\\n';\n};\n\nRenderer.prototype.blockquote = function(quote) {\n  return '<blockquote>\\n' + quote + '</blockquote>\\n';\n};\n\nRenderer.prototype.html = function(html) {\n  return html;\n};\n\nRenderer.prototype.heading = function(text, level, raw) {\n  return '<h'\n    + level\n    + ' id=\"'\n    + this.options.headerPrefix\n    + raw.toLowerCase().replace(/[^\\w]+/g, '-')\n    + '\">'\n    + text\n    + '</h'\n    + level\n    + '>\\n';\n};\n\nRenderer.prototype.hr = function() {\n  return this.options.xhtml ? '<hr/>\\n' : '<hr>\\n';\n};\n\nRenderer.prototype.list = function(body, ordered) {\n  var type = ordered ? 'ol' : 'ul';\n  return '<' + type + '>\\n' + body + '</' + type + '>\\n';\n};\n\nRenderer.prototype.listitem = function(text) {\n  return '<li>' + text + '</li>\\n';\n};\n\nRenderer.prototype.paragraph = function(text) {\n  return '<p>' + text + '</p>\\n';\n};\n\nRenderer.prototype.table = function(header, body) {\n  return '<table>\\n'\n    + '<thead>\\n'\n    + header\n    + '</thead>\\n'\n    + '<tbody>\\n'\n    + body\n    + '</tbody>\\n'\n    + '</table>\\n';\n};\n\nRenderer.prototype.tablerow = function(content) {\n  return '<tr>\\n' + content + '</tr>\\n';\n};\n\nRenderer.prototype.tablecell = function(content, flags) {\n  var type = flags.header ? 'th' : 'td';\n  var tag = flags.align\n    ? '<' + type + ' style=\"text-align:' + flags.align + '\">'\n    : '<' + type + '>';\n  return tag + content + '</' + type + '>\\n';\n};\n\n// span level renderer\nRenderer.prototype.strong = function(text) {\n  return '<strong>' + text + '</strong>';\n};\n\nRenderer.prototype.em = function(text) {\n  return '<em>' + text + '</em>';\n};\n\nRenderer.prototype.codespan = function(text) {\n  return '<code>' + text + '</code>';\n};\n\nRenderer.prototype.br = function() {\n  return this.options.xhtml ? '<br/>' : '<br>';\n};\n\nRenderer.prototype.del = function(text) {\n  return '<del>' + text + '</del>';\n};\n\nRenderer.prototype.link = function(href, title, text) {\n  if (this.options.sanitize) {\n    try {\n      var prot = decodeURIComponent(unescape(href))\n        .replace(/[^\\w:]/g, '')\n        .toLowerCase();\n    } catch (e) {\n      return '';\n    }\n    if (prot.indexOf('javascript:') === 0) {\n      return '';\n    }\n  }\n  var out = '<a href=\"' + href + '\"';\n  if (title) {\n    out += ' title=\"' + title + '\"';\n  }\n  out += '>' + text + '</a>';\n  return out;\n};\n\nRenderer.prototype.image = function(href, title, text) {\n  var out = '<img src=\"' + href + '\" alt=\"' + text + '\"';\n  if (title) {\n    out += ' title=\"' + title + '\"';\n  }\n  out += this.options.xhtml ? '/>' : '>';\n  return out;\n};\n\n/**\n * Parsing & Compiling\n */\n\nfunction Parser(options) {\n  this.tokens = [];\n  this.token = null;\n  this.options = options || marked.defaults;\n  this.options.renderer = this.options.renderer || new Renderer;\n  this.renderer = this.options.renderer;\n  this.renderer.options = this.options;\n}\n\n/**\n * Static Parse Method\n */\n\nParser.parse = function(src, options, renderer) {\n  var parser = new Parser(options, renderer);\n  return parser.parse(src);\n};\n\n/**\n * Parse Loop\n */\n\nParser.prototype.parse = function(src) {\n  this.inline = new InlineLexer(src.links, this.options, this.renderer);\n  this.tokens = src.reverse();\n\n  var out = '';\n  while (this.next()) {\n    out += this.tok();\n  }\n\n  return out;\n};\n\n/**\n * Next Token\n */\n\nParser.prototype.next = function() {\n  return this.token = this.tokens.pop();\n};\n\n/**\n * Preview Next Token\n */\n\nParser.prototype.peek = function() {\n  return this.tokens[this.tokens.length - 1] || 0;\n};\n\n/**\n * Parse Text Tokens\n */\n\nParser.prototype.parseText = function() {\n  var body = this.token.text;\n\n  while (this.peek().type === 'text') {\n    body += '\\n' + this.next().text;\n  }\n\n  return this.inline.output(body);\n};\n\n/**\n * Parse Current Token\n */\n\nParser.prototype.tok = function() {\n  switch (this.token.type) {\n    case 'space': {\n      return '';\n    }\n    case 'hr': {\n      return this.renderer.hr();\n    }\n    case 'heading': {\n      return this.renderer.heading(\n        this.inline.output(this.token.text),\n        this.token.depth,\n        this.token.text);\n    }\n    case 'code': {\n      return this.renderer.code(this.token.text,\n        this.token.lang,\n        this.token.escaped);\n    }\n    case 'table': {\n      var header = ''\n        , body = ''\n        , i\n        , row\n        , cell\n        , flags\n        , j;\n\n      // header\n      cell = '';\n      for (i = 0; i < this.token.header.length; i++) {\n        flags = { header: true, align: this.token.align[i] };\n        cell += this.renderer.tablecell(\n          this.inline.output(this.token.header[i]),\n          { header: true, align: this.token.align[i] }\n        );\n      }\n      header += this.renderer.tablerow(cell);\n\n      for (i = 0; i < this.token.cells.length; i++) {\n        row = this.token.cells[i];\n\n        cell = '';\n        for (j = 0; j < row.length; j++) {\n          cell += this.renderer.tablecell(\n            this.inline.output(row[j]),\n            { header: false, align: this.token.align[j] }\n          );\n        }\n\n        body += this.renderer.tablerow(cell);\n      }\n      return this.renderer.table(header, body);\n    }\n    case 'blockquote_start': {\n      var body = '';\n\n      while (this.next().type !== 'blockquote_end') {\n        body += this.tok();\n      }\n\n      return this.renderer.blockquote(body);\n    }\n    case 'list_start': {\n      var body = ''\n        , ordered = this.token.ordered;\n\n      while (this.next().type !== 'list_end') {\n        body += this.tok();\n      }\n\n      return this.renderer.list(body, ordered);\n    }\n    case 'list_item_start': {\n      var body = '';\n\n      while (this.next().type !== 'list_item_end') {\n        body += this.token.type === 'text'\n          ? this.parseText()\n          : this.tok();\n      }\n\n      return this.renderer.listitem(body);\n    }\n    case 'loose_item_start': {\n      var body = '';\n\n      while (this.next().type !== 'list_item_end') {\n        body += this.tok();\n      }\n\n      return this.renderer.listitem(body);\n    }\n    case 'html': {\n      var html = !this.token.pre && !this.options.pedantic\n        ? this.inline.output(this.token.text)\n        : this.token.text;\n      return this.renderer.html(html);\n    }\n    case 'paragraph': {\n      return this.renderer.paragraph(this.inline.output(this.token.text));\n    }\n    case 'text': {\n      return this.renderer.paragraph(this.parseText());\n    }\n  }\n};\n\n/**\n * Helpers\n */\n\nfunction escape(html, encode) {\n  return html\n    .replace(!encode ? /&(?!#?\\w+;)/g : /&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;');\n}\n\nfunction unescape(html) {\n  return html.replace(/&([#\\w]+);/g, function(_, n) {\n    n = n.toLowerCase();\n    if (n === 'colon') return ':';\n    if (n.charAt(0) === '#') {\n      return n.charAt(1) === 'x'\n        ? String.fromCharCode(parseInt(n.substring(2), 16))\n        : String.fromCharCode(+n.substring(1));\n    }\n    return '';\n  });\n}\n\nfunction replace(regex, opt) {\n  regex = regex.source;\n  opt = opt || '';\n  return function self(name, val) {\n    if (!name) return new RegExp(regex, opt);\n    val = val.source || val;\n    val = val.replace(/(^|[^\\[])\\^/g, '$1');\n    regex = regex.replace(name, val);\n    return self;\n  };\n}\n\nfunction noop() {}\nnoop.exec = noop;\n\nfunction merge(obj) {\n  var i = 1\n    , target\n    , key;\n\n  for (; i < arguments.length; i++) {\n    target = arguments[i];\n    for (key in target) {\n      if (Object.prototype.hasOwnProperty.call(target, key)) {\n        obj[key] = target[key];\n      }\n    }\n  }\n\n  return obj;\n}\n\n\n/**\n * Marked\n */\n\nfunction marked(src, opt, callback) {\n  if (callback || typeof opt === 'function') {\n    if (!callback) {\n      callback = opt;\n      opt = null;\n    }\n\n    opt = merge({}, marked.defaults, opt || {});\n\n    var highlight = opt.highlight\n      , tokens\n      , pending\n      , i = 0;\n\n    try {\n      tokens = Lexer.lex(src, opt)\n    } catch (e) {\n      return callback(e);\n    }\n\n    pending = tokens.length;\n\n    var done = function() {\n      var out, err;\n\n      try {\n        out = Parser.parse(tokens, opt);\n      } catch (e) {\n        err = e;\n      }\n\n      opt.highlight = highlight;\n\n      return err\n        ? callback(err)\n        : callback(null, out);\n    };\n\n    if (!highlight || highlight.length < 3) {\n      return done();\n    }\n\n    delete opt.highlight;\n\n    if (!pending) return done();\n\n    for (; i < tokens.length; i++) {\n      (function(token) {\n        if (token.type !== 'code') {\n          return --pending || done();\n        }\n        return highlight(token.text, token.lang, function(err, code) {\n          if (code == null || code === token.text) {\n            return --pending || done();\n          }\n          token.text = code;\n          token.escaped = true;\n          --pending || done();\n        });\n      })(tokens[i]);\n    }\n\n    return;\n  }\n  try {\n    if (opt) opt = merge({}, marked.defaults, opt);\n    return Parser.parse(Lexer.lex(src, opt), opt);\n  } catch (e) {\n    e.message += '\\nPlease report this to https://github.com/chjj/marked.';\n    if ((opt || marked.defaults).silent) {\n      return '<p>An error occured:</p><pre>'\n        + escape(e.message + '', true)\n        + '</pre>';\n    }\n    throw e;\n  }\n}\n\n/**\n * Options\n */\n\nmarked.options =\nmarked.setOptions = function(opt) {\n  merge(marked.defaults, opt);\n  return marked;\n};\n\nmarked.defaults = {\n  gfm: true,\n  tables: true,\n  breaks: false,\n  pedantic: false,\n  sanitize: false,\n  smartLists: false,\n  silent: false,\n  highlight: null,\n  langPrefix: 'lang-',\n  smartypants: false,\n  headerPrefix: '',\n  renderer: new Renderer,\n  xhtml: false\n};\n\n/**\n * Expose\n */\n\nmarked.Parser = Parser;\nmarked.parser = Parser.parse;\n\nmarked.Renderer = Renderer;\n\nmarked.Lexer = Lexer;\nmarked.lexer = Lexer.lex;\n\nmarked.InlineLexer = InlineLexer;\nmarked.inlineLexer = InlineLexer.output;\n\nmarked.parse = marked;\n\nif (typeof exports === 'object') {\n  module.exports = marked;\n} else if (typeof define === 'function' && define.amd) {\n  define(function() { return marked; });\n} else {\n  this.marked = marked;\n}\n\n}).call(function() {\n  return this || (typeof window !== 'undefined' ? window : global);\n}());",

"highlight.js":"(function() {\n\nvar hljs = require('highlight_highlight.js')\nhljs.registerLanguage('bash',       require('highlight_bash.js'))\nhljs.registerLanguage('xml',        require('highlight_xml.js'))\nhljs.registerLanguage('javascript', require('highlight_javascript.js'))\nhljs.registerLanguage('json',       require('highlight_json.js'))\nhljs.registerLanguage('css',        require('highlight_css.js'))\nhljs.registerLanguage('markdown',   require('highlight_markdown.js'))\n\nif (typeof exports === 'object') {\n  module.exports = hljs\n} else if (typeof define === 'function' && define.amd) {\n  define(function() { return hljs; });\n} else {\n  this.hljs = hljs;\n}\n\n}).call(function() {\n  return this || (typeof window !== 'undefined' ? window : global);\n}())",

"highlight_highlight.js":"/*\nSyntax highlighting with language autodetection.\nhttps://highlightjs.org/\n*/\n\n(function(factory) {\n\n  // Setup highlight.js for different environments. First is Node.js or\n  // CommonJS.\n  if(typeof exports !== 'undefined') {\n    factory(exports);\n  } else {\n    // Export hljs globally even when using AMD for cases when this script\n    // is loaded with others that may still expect a global hljs.\n    window.hljs = factory({});\n\n    // Finally register the global hljs with AMD.\n    if(typeof define === 'function' && define.amd) {\n      define([], function() {\n        return window.hljs;\n      });\n    }\n  }\n\n}(function(hljs) {\n\n  /* Utility functions */\n\n  function escape(value) {\n    return value.replace(/&/gm, '&amp;').replace(/</gm, '&lt;').replace(/>/gm, '&gt;');\n  }\n\n  function tag(node) {\n    return node.nodeName.toLowerCase();\n  }\n\n  function testRe(re, lexeme) {\n    var match = re && re.exec(lexeme);\n    return match && match.index == 0;\n  }\n\n  function blockLanguage(block) {\n    var classes = (block.className + ' ' + (block.parentNode ? block.parentNode.className : '')).split(/\\s+/);\n    classes = classes.map(function(c) {return c.replace(/^lang(uage)?-/, '');});\n    return classes.filter(function(c) {return getLanguage(c) || /no(-?)highlight/.test(c);})[0];\n  }\n\n  function inherit(parent, obj) {\n    var result = {};\n    for (var key in parent)\n      result[key] = parent[key];\n    if (obj)\n      for (var key in obj)\n        result[key] = obj[key];\n    return result;\n  };\n\n  /* Stream merging */\n\n  function nodeStream(node) {\n    var result = [];\n    (function _nodeStream(node, offset) {\n      for (var child = node.firstChild; child; child = child.nextSibling) {\n        if (child.nodeType == 3)\n          offset += child.nodeValue.length;\n        else if (child.nodeType == 1) {\n          result.push({\n            event: 'start',\n            offset: offset,\n            node: child\n          });\n          offset = _nodeStream(child, offset);\n          // Prevent void elements from having an end tag that would actually\n          // double them in the output. There are more void elements in HTML\n          // but we list only those realistically expected in code display.\n          if (!tag(child).match(/br|hr|img|input/)) {\n            result.push({\n              event: 'stop',\n              offset: offset,\n              node: child\n            });\n          }\n        }\n      }\n      return offset;\n    })(node, 0);\n    return result;\n  }\n\n  function mergeStreams(original, highlighted, value) {\n    var processed = 0;\n    var result = '';\n    var nodeStack = [];\n\n    function selectStream() {\n      if (!original.length || !highlighted.length) {\n        return original.length ? original : highlighted;\n      }\n      if (original[0].offset != highlighted[0].offset) {\n        return (original[0].offset < highlighted[0].offset) ? original : highlighted;\n      }\n\n      /*\n      To avoid starting the stream just before it should stop the order is\n      ensured that original always starts first and closes last:\n\n      if (event1 == 'start' && event2 == 'start')\n        return original;\n      if (event1 == 'start' && event2 == 'stop')\n        return highlighted;\n      if (event1 == 'stop' && event2 == 'start')\n        return original;\n      if (event1 == 'stop' && event2 == 'stop')\n        return highlighted;\n\n      ... which is collapsed to:\n      */\n      return highlighted[0].event == 'start' ? original : highlighted;\n    }\n\n    function open(node) {\n      function attr_str(a) {return ' ' + a.nodeName + '=\"' + escape(a.value) + '\"';}\n      result += '<' + tag(node) + Array.prototype.map.call(node.attributes, attr_str).join('') + '>';\n    }\n\n    function close(node) {\n      result += '</' + tag(node) + '>';\n    }\n\n    function render(event) {\n      (event.event == 'start' ? open : close)(event.node);\n    }\n\n    while (original.length || highlighted.length) {\n      var stream = selectStream();\n      result += escape(value.substr(processed, stream[0].offset - processed));\n      processed = stream[0].offset;\n      if (stream == original) {\n        /*\n        On any opening or closing tag of the original markup we first close\n        the entire highlighted node stack, then render the original tag along\n        with all the following original tags at the same offset and then\n        reopen all the tags on the highlighted stack.\n        */\n        nodeStack.reverse().forEach(close);\n        do {\n          render(stream.splice(0, 1)[0]);\n          stream = selectStream();\n        } while (stream == original && stream.length && stream[0].offset == processed);\n        nodeStack.reverse().forEach(open);\n      } else {\n        if (stream[0].event == 'start') {\n          nodeStack.push(stream[0].node);\n        } else {\n          nodeStack.pop();\n        }\n        render(stream.splice(0, 1)[0]);\n      }\n    }\n    return result + escape(value.substr(processed));\n  }\n\n  /* Initialization */\n\n  function compileLanguage(language) {\n\n    function reStr(re) {\n        return (re && re.source) || re;\n    }\n\n    function langRe(value, global) {\n      return RegExp(\n        reStr(value),\n        'm' + (language.case_insensitive ? 'i' : '') + (global ? 'g' : '')\n      );\n    }\n\n    function compileMode(mode, parent) {\n      if (mode.compiled)\n        return;\n      mode.compiled = true;\n\n      mode.keywords = mode.keywords || mode.beginKeywords;\n      if (mode.keywords) {\n        var compiled_keywords = {};\n\n        var flatten = function(className, str) {\n          if (language.case_insensitive) {\n            str = str.toLowerCase();\n          }\n          str.split(' ').forEach(function(kw) {\n            var pair = kw.split('|');\n            compiled_keywords[pair[0]] = [className, pair[1] ? Number(pair[1]) : 1];\n          });\n        };\n\n        if (typeof mode.keywords == 'string') { // string\n          flatten('keyword', mode.keywords);\n        } else {\n          Object.keys(mode.keywords).forEach(function (className) {\n            flatten(className, mode.keywords[className]);\n          });\n        }\n        mode.keywords = compiled_keywords;\n      }\n      mode.lexemesRe = langRe(mode.lexemes || /\\b[A-Za-z0-9_]+\\b/, true);\n\n      if (parent) {\n        if (mode.beginKeywords) {\n          mode.begin = '\\\\b(' + mode.beginKeywords.split(' ').join('|') + ')\\\\b';\n        }\n        if (!mode.begin)\n          mode.begin = /\\B|\\b/;\n        mode.beginRe = langRe(mode.begin);\n        if (!mode.end && !mode.endsWithParent)\n          mode.end = /\\B|\\b/;\n        if (mode.end)\n          mode.endRe = langRe(mode.end);\n        mode.terminator_end = reStr(mode.end) || '';\n        if (mode.endsWithParent && parent.terminator_end)\n          mode.terminator_end += (mode.end ? '|' : '') + parent.terminator_end;\n      }\n      if (mode.illegal)\n        mode.illegalRe = langRe(mode.illegal);\n      if (mode.relevance === undefined)\n        mode.relevance = 1;\n      if (!mode.contains) {\n        mode.contains = [];\n      }\n      var expanded_contains = [];\n      mode.contains.forEach(function(c) {\n        if (c.variants) {\n          c.variants.forEach(function(v) {expanded_contains.push(inherit(c, v));});\n        } else {\n          expanded_contains.push(c == 'self' ? mode : c);\n        }\n      });\n      mode.contains = expanded_contains;\n      mode.contains.forEach(function(c) {compileMode(c, mode);});\n\n      if (mode.starts) {\n        compileMode(mode.starts, parent);\n      }\n\n      var terminators =\n        mode.contains.map(function(c) {\n          return c.beginKeywords ? '\\\\.?(' + c.begin + ')\\\\.?' : c.begin;\n        })\n        .concat([mode.terminator_end, mode.illegal])\n        .map(reStr)\n        .filter(Boolean);\n      mode.terminators = terminators.length ? langRe(terminators.join('|'), true) : {exec: function(s) {return null;}};\n    }\n\n    compileMode(language);\n  }\n\n  /*\n  Core highlighting function. Accepts a language name, or an alias, and a\n  string with the code to highlight. Returns an object with the following\n  properties:\n\n  - relevance (int)\n  - value (an HTML string with highlighting markup)\n\n  */\n  function highlight(name, value, ignore_illegals, continuation) {\n\n    function subMode(lexeme, mode) {\n      for (var i = 0; i < mode.contains.length; i++) {\n        if (testRe(mode.contains[i].beginRe, lexeme)) {\n          return mode.contains[i];\n        }\n      }\n    }\n\n    function endOfMode(mode, lexeme) {\n      if (testRe(mode.endRe, lexeme)) {\n        return mode;\n      }\n      if (mode.endsWithParent) {\n        return endOfMode(mode.parent, lexeme);\n      }\n    }\n\n    function isIllegal(lexeme, mode) {\n      return !ignore_illegals && testRe(mode.illegalRe, lexeme);\n    }\n\n    function keywordMatch(mode, match) {\n      var match_str = language.case_insensitive ? match[0].toLowerCase() : match[0];\n      return mode.keywords.hasOwnProperty(match_str) && mode.keywords[match_str];\n    }\n\n    function buildSpan(classname, insideSpan, leaveOpen, noPrefix) {\n      var classPrefix = noPrefix ? '' : options.classPrefix,\n          openSpan    = '<span class=\"' + classPrefix,\n          closeSpan   = leaveOpen ? '' : '</span>';\n\n      openSpan += classname + '\">';\n\n      return openSpan + insideSpan + closeSpan;\n    }\n\n    function processKeywords() {\n      if (!top.keywords)\n        return escape(mode_buffer);\n      var result = '';\n      var last_index = 0;\n      top.lexemesRe.lastIndex = 0;\n      var match = top.lexemesRe.exec(mode_buffer);\n      while (match) {\n        result += escape(mode_buffer.substr(last_index, match.index - last_index));\n        var keyword_match = keywordMatch(top, match);\n        if (keyword_match) {\n          relevance += keyword_match[1];\n          result += buildSpan(keyword_match[0], escape(match[0]));\n        } else {\n          result += escape(match[0]);\n        }\n        last_index = top.lexemesRe.lastIndex;\n        match = top.lexemesRe.exec(mode_buffer);\n      }\n      return result + escape(mode_buffer.substr(last_index));\n    }\n\n    function processSubLanguage() {\n      if (top.subLanguage && !languages[top.subLanguage]) {\n        return escape(mode_buffer);\n      }\n      var result = top.subLanguage ? highlight(top.subLanguage, mode_buffer, true, continuations[top.subLanguage]) : highlightAuto(mode_buffer);\n      // Counting embedded language score towards the host language may be disabled\n      // with zeroing the containing mode relevance. Usecase in point is Markdown that\n      // allows XML everywhere and makes every XML snippet to have a much larger Markdown\n      // score.\n      if (top.relevance > 0) {\n        relevance += result.relevance;\n      }\n      if (top.subLanguageMode == 'continuous') {\n        continuations[top.subLanguage] = result.top;\n      }\n      return buildSpan(result.language, result.value, false, true);\n    }\n\n    function processBuffer() {\n      return top.subLanguage !== undefined ? processSubLanguage() : processKeywords();\n    }\n\n    function startNewMode(mode, lexeme) {\n      var markup = mode.className? buildSpan(mode.className, '', true): '';\n      if (mode.returnBegin) {\n        result += markup;\n        mode_buffer = '';\n      } else if (mode.excludeBegin) {\n        result += escape(lexeme) + markup;\n        mode_buffer = '';\n      } else {\n        result += markup;\n        mode_buffer = lexeme;\n      }\n      top = Object.create(mode, {parent: {value: top}});\n    }\n\n    function processLexeme(buffer, lexeme) {\n\n      mode_buffer += buffer;\n      if (lexeme === undefined) {\n        result += processBuffer();\n        return 0;\n      }\n\n      var new_mode = subMode(lexeme, top);\n      if (new_mode) {\n        result += processBuffer();\n        startNewMode(new_mode, lexeme);\n        return new_mode.returnBegin ? 0 : lexeme.length;\n      }\n\n      var end_mode = endOfMode(top, lexeme);\n      if (end_mode) {\n        var origin = top;\n        if (!(origin.returnEnd || origin.excludeEnd)) {\n          mode_buffer += lexeme;\n        }\n        result += processBuffer();\n        do {\n          if (top.className) {\n            result += '</span>';\n          }\n          relevance += top.relevance;\n          top = top.parent;\n        } while (top != end_mode.parent);\n        if (origin.excludeEnd) {\n          result += escape(lexeme);\n        }\n        mode_buffer = '';\n        if (end_mode.starts) {\n          startNewMode(end_mode.starts, '');\n        }\n        return origin.returnEnd ? 0 : lexeme.length;\n      }\n\n      if (isIllegal(lexeme, top))\n        throw new Error('Illegal lexeme \"' + lexeme + '\" for mode \"' + (top.className || '<unnamed>') + '\"');\n\n      /*\n      Parser should not reach this point as all types of lexemes should be caught\n      earlier, but if it does due to some bug make sure it advances at least one\n      character forward to prevent infinite looping.\n      */\n      mode_buffer += lexeme;\n      return lexeme.length || 1;\n    }\n\n    var language = getLanguage(name);\n    if (!language) {\n      throw new Error('Unknown language: \"' + name + '\"');\n    }\n\n    compileLanguage(language);\n    var top = continuation || language;\n    var continuations = {}; // keep continuations for sub-languages\n    var result = '';\n    for(var current = top; current != language; current = current.parent) {\n      if (current.className) {\n        result = buildSpan(current.className, '', true) + result;\n      }\n    }\n    var mode_buffer = '';\n    var relevance = 0;\n    try {\n      var match, count, index = 0;\n      while (true) {\n        top.terminators.lastIndex = index;\n        match = top.terminators.exec(value);\n        if (!match)\n          break;\n        count = processLexeme(value.substr(index, match.index - index), match[0]);\n        index = match.index + count;\n      }\n      processLexeme(value.substr(index));\n      for(var current = top; current.parent; current = current.parent) { // close dangling modes\n        if (current.className) {\n          result += '</span>';\n        }\n      };\n      return {\n        relevance: relevance,\n        value: result,\n        language: name,\n        top: top\n      };\n    } catch (e) {\n      if (e.message.indexOf('Illegal') != -1) {\n        return {\n          relevance: 0,\n          value: escape(value)\n        };\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  /*\n  Highlighting with language detection. Accepts a string with the code to\n  highlight. Returns an object with the following properties:\n\n  - language (detected language)\n  - relevance (int)\n  - value (an HTML string with highlighting markup)\n  - second_best (object with the same structure for second-best heuristically\n    detected language, may be absent)\n\n  */\n  function highlightAuto(text, languageSubset) {\n    languageSubset = languageSubset || options.languages || Object.keys(languages);\n    var result = {\n      relevance: 0,\n      value: escape(text)\n    };\n    var second_best = result;\n    languageSubset.forEach(function(name) {\n      if (!getLanguage(name)) {\n        return;\n      }\n      var current = highlight(name, text, false);\n      current.language = name;\n      if (current.relevance > second_best.relevance) {\n        second_best = current;\n      }\n      if (current.relevance > result.relevance) {\n        second_best = result;\n        result = current;\n      }\n    });\n    if (second_best.language) {\n      result.second_best = second_best;\n    }\n    return result;\n  }\n\n  /*\n  Post-processing of the highlighted markup:\n\n  - replace TABs with something more useful\n  - replace real line-breaks with '<br>' for non-pre containers\n\n  */\n  function fixMarkup(value) {\n    if (options.tabReplace) {\n      value = value.replace(/^((<[^>]+>|\\t)+)/gm, function(match, p1, offset, s) {\n        return p1.replace(/\\t/g, options.tabReplace);\n      });\n    }\n    if (options.useBR) {\n      value = value.replace(/\\n/g, '<br>');\n    }\n    return value;\n  }\n\n  function buildClassName(prevClassName, currentLang, resultLang) {\n    var language = currentLang ? aliases[currentLang] : resultLang,\n        result   = [prevClassName.trim()];\n\n    if (!prevClassName.match(/(\\s|^)hljs(\\s|$)/)) {\n      result.push('hljs');\n    }\n\n    if (language) {\n      result.push(language);\n    }\n\n    return result.join(' ').trim();\n  }\n\n  /*\n  Applies highlighting to a DOM node containing code. Accepts a DOM node and\n  two optional parameters for fixMarkup.\n  */\n  function highlightBlock(block) {\n    var language = blockLanguage(block);\n    if (/no(-?)highlight/.test(language))\n        return;\n\n    var node;\n    if (options.useBR) {\n      node = document.createElementNS('http://www.w3.org/1999/xhtml', 'div');\n      node.innerHTML = block.innerHTML.replace(/\\n/g, '').replace(/<br[ \\/]*>/g, '\\n');\n    } else {\n      node = block;\n    }\n    var text = node.textContent;\n    var result = language ? highlight(language, text, true) : highlightAuto(text);\n\n    var originalStream = nodeStream(node);\n    if (originalStream.length) {\n      var resultNode = document.createElementNS('http://www.w3.org/1999/xhtml', 'div');\n      resultNode.innerHTML = result.value;\n      result.value = mergeStreams(originalStream, nodeStream(resultNode), text);\n    }\n    result.value = fixMarkup(result.value);\n\n    block.innerHTML = result.value;\n    block.className = buildClassName(block.className, language, result.language);\n    block.result = {\n      language: result.language,\n      re: result.relevance\n    };\n    if (result.second_best) {\n      block.second_best = {\n        language: result.second_best.language,\n        re: result.second_best.relevance\n      };\n    }\n  }\n\n  var options = {\n    classPrefix: 'hljs-',\n    tabReplace: null,\n    useBR: false,\n    languages: undefined\n  };\n\n  /*\n  Updates highlight.js global options with values passed in the form of an object\n  */\n  function configure(user_options) {\n    options = inherit(options, user_options);\n  }\n\n  /*\n  Applies highlighting to all <pre><code>..</code></pre> blocks on a page.\n  */\n  function initHighlighting() {\n    if (initHighlighting.called)\n      return;\n    initHighlighting.called = true;\n\n    var blocks = document.querySelectorAll('pre code');\n    Array.prototype.forEach.call(blocks, highlightBlock);\n  }\n\n  /*\n  Attaches highlighting to the page load event.\n  */\n  function initHighlightingOnLoad() {\n    addEventListener('DOMContentLoaded', initHighlighting, false);\n    addEventListener('load', initHighlighting, false);\n  }\n\n  var languages = {};\n  var aliases = {};\n\n  function registerLanguage(name, language) {\n    var lang = languages[name] = language(hljs);\n    if (lang.aliases) {\n      lang.aliases.forEach(function(alias) {aliases[alias] = name;});\n    }\n  }\n\n  function listLanguages() {\n    return Object.keys(languages);\n  }\n\n  function getLanguage(name) {\n    return languages[name] || languages[aliases[name]];\n  }\n\n  /* Interface definition */\n\n  hljs.highlight = highlight;\n  hljs.highlightAuto = highlightAuto;\n  hljs.fixMarkup = fixMarkup;\n  hljs.highlightBlock = highlightBlock;\n  hljs.configure = configure;\n  hljs.initHighlighting = initHighlighting;\n  hljs.initHighlightingOnLoad = initHighlightingOnLoad;\n  hljs.registerLanguage = registerLanguage;\n  hljs.listLanguages = listLanguages;\n  hljs.getLanguage = getLanguage;\n  hljs.inherit = inherit;\n\n  // Common regexps\n  hljs.IDENT_RE = '[a-zA-Z][a-zA-Z0-9_]*';\n  hljs.UNDERSCORE_IDENT_RE = '[a-zA-Z_][a-zA-Z0-9_]*';\n  hljs.NUMBER_RE = '\\\\b\\\\d+(\\\\.\\\\d+)?';\n  hljs.C_NUMBER_RE = '(\\\\b0[xX][a-fA-F0-9]+|(\\\\b\\\\d+(\\\\.\\\\d*)?|\\\\.\\\\d+)([eE][-+]?\\\\d+)?)'; // 0x..., 0..., decimal, float\n  hljs.BINARY_NUMBER_RE = '\\\\b(0b[01]+)'; // 0b...\n  hljs.RE_STARTERS_RE = '!|!=|!==|%|%=|&|&&|&=|\\\\*|\\\\*=|\\\\+|\\\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\\\?|\\\\[|\\\\{|\\\\(|\\\\^|\\\\^=|\\\\||\\\\|=|\\\\|\\\\||~';\n\n  // Common modes\n  hljs.BACKSLASH_ESCAPE = {\n    begin: '\\\\\\\\[\\\\s\\\\S]', relevance: 0\n  };\n  hljs.APOS_STRING_MODE = {\n    className: 'string',\n    begin: '\\'', end: '\\'',\n    illegal: '\\\\n',\n    contains: [hljs.BACKSLASH_ESCAPE]\n  };\n  hljs.QUOTE_STRING_MODE = {\n    className: 'string',\n    begin: '\"', end: '\"',\n    illegal: '\\\\n',\n    contains: [hljs.BACKSLASH_ESCAPE]\n  };\n  hljs.PHRASAL_WORDS_MODE = {\n    begin: /\\b(a|an|the|are|I|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such)\\b/\n  };\n  hljs.C_LINE_COMMENT_MODE = {\n    className: 'comment',\n    begin: '//', end: '$',\n    contains: [hljs.PHRASAL_WORDS_MODE]\n  };\n  hljs.C_BLOCK_COMMENT_MODE = {\n    className: 'comment',\n    begin: '/\\\\*', end: '\\\\*/',\n    contains: [hljs.PHRASAL_WORDS_MODE]\n  };\n  hljs.HASH_COMMENT_MODE = {\n    className: 'comment',\n    begin: '#', end: '$',\n    contains: [hljs.PHRASAL_WORDS_MODE]\n  };\n  hljs.NUMBER_MODE = {\n    className: 'number',\n    begin: hljs.NUMBER_RE,\n    relevance: 0\n  };\n  hljs.C_NUMBER_MODE = {\n    className: 'number',\n    begin: hljs.C_NUMBER_RE,\n    relevance: 0\n  };\n  hljs.BINARY_NUMBER_MODE = {\n    className: 'number',\n    begin: hljs.BINARY_NUMBER_RE,\n    relevance: 0\n  };\n  hljs.CSS_NUMBER_MODE = {\n    className: 'number',\n    begin: hljs.NUMBER_RE + '(' +\n      '%|em|ex|ch|rem'  +\n      '|vw|vh|vmin|vmax' +\n      '|cm|mm|in|pt|pc|px' +\n      '|deg|grad|rad|turn' +\n      '|s|ms' +\n      '|Hz|kHz' +\n      '|dpi|dpcm|dppx' +\n      ')?',\n    relevance: 0\n  };\n  hljs.REGEXP_MODE = {\n    className: 'regexp',\n    begin: /\\//, end: /\\/[gimuy]*/,\n    illegal: /\\n/,\n    contains: [\n      hljs.BACKSLASH_ESCAPE,\n      {\n        begin: /\\[/, end: /\\]/,\n        relevance: 0,\n        contains: [hljs.BACKSLASH_ESCAPE]\n      }\n    ]\n  };\n  hljs.TITLE_MODE = {\n    className: 'title',\n    begin: hljs.IDENT_RE,\n    relevance: 0\n  };\n  hljs.UNDERSCORE_TITLE_MODE = {\n    className: 'title',\n    begin: hljs.UNDERSCORE_IDENT_RE,\n    relevance: 0\n  };\n\n  return hljs;\n}));",

"highlight_bash.js":"module.exports = function(hljs) {\n  var VAR = {\n    className: 'variable',\n    variants: [\n      {begin: /\\$[\\w\\d#@][\\w\\d_]*/},\n      {begin: /\\$\\{(.*?)\\}/}\n    ]\n  };\n  var QUOTE_STRING = {\n    className: 'string',\n    begin: /\"/, end: /\"/,\n    contains: [\n      hljs.BACKSLASH_ESCAPE,\n      VAR,\n      {\n        className: 'variable',\n        begin: /\\$\\(/, end: /\\)/,\n        contains: [hljs.BACKSLASH_ESCAPE]\n      }\n    ]\n  };\n  var APOS_STRING = {\n    className: 'string',\n    begin: /'/, end: /'/\n  };\n\n  return {\n    aliases: ['sh', 'zsh'],\n    lexemes: /-?[a-z\\.]+/,\n    keywords: {\n      keyword:\n        'if then else elif fi for while in do done case esac function',\n      literal:\n        'true false',\n      built_in:\n        // Shell built-ins\n        // http://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html\n        'break cd continue eval exec exit export getopts hash pwd readonly return shift test times ' +\n        'trap umask unset ' +\n        // Bash built-ins\n        'alias bind builtin caller command declare echo enable help let local logout mapfile printf ' +\n        'read readarray source type typeset ulimit unalias ' +\n        // Shell modifiers\n        'set shopt ' +\n        // Zsh built-ins\n        'autoload bg bindkey bye cap chdir clone comparguments compcall compctl compdescribe compfiles ' +\n        'compgroups compquote comptags comptry compvalues dirs disable disown echotc echoti emulate ' +\n        'fc fg float functions getcap getln history integer jobs kill limit log noglob popd print ' +\n        'pushd pushln rehash sched setcap setopt stat suspend ttyctl unfunction unhash unlimit ' +\n        'unsetopt vared wait whence where which zcompile zformat zftp zle zmodload zparseopts zprof ' +\n        'zpty zregexparse zsocket zstyle ztcp',\n      operator:\n        '-ne -eq -lt -gt -f -d -e -s -l -a' // relevance booster\n    },\n    contains: [\n      {\n        className: 'shebang',\n        begin: /^#![^\\n]+sh\\s*$/,\n        relevance: 10\n      },\n      {\n        className: 'function',\n        begin: /\\w[\\w\\d_]*\\s*\\(\\s*\\)\\s*\\{/,\n        returnBegin: true,\n        contains: [hljs.inherit(hljs.TITLE_MODE, {begin: /\\w[\\w\\d_]*/})],\n        relevance: 0\n      },\n      hljs.HASH_COMMENT_MODE,\n      hljs.NUMBER_MODE,\n      QUOTE_STRING,\n      APOS_STRING,\n      VAR\n    ]\n  };\n};",

"highlight_xml.js":"module.exports = function(hljs) {\n  var XML_IDENT_RE = '[A-Za-z0-9\\\\._:-]+';\n  var PHP = {\n    begin: /<\\?(php)?(?!\\w)/, end: /\\?>/,\n    subLanguage: 'php', subLanguageMode: 'continuous'\n  };\n  var TAG_INTERNALS = {\n    endsWithParent: true,\n    illegal: /</,\n    relevance: 0,\n    contains: [\n      PHP,\n      {\n        className: 'attribute',\n        begin: XML_IDENT_RE,\n        relevance: 0\n      },\n      {\n        begin: '=',\n        relevance: 0,\n        contains: [\n          {\n            className: 'value',\n            contains: [PHP],\n            variants: [\n              {begin: /\"/, end: /\"/},\n              {begin: /'/, end: /'/},\n              {begin: /[^\\s\\/>]+/}\n            ]\n          }\n        ]\n      }\n    ]\n  };\n  return {\n    aliases: ['html', 'xhtml', 'rss', 'atom', 'xsl', 'plist'],\n    case_insensitive: true,\n    contains: [\n      {\n        className: 'doctype',\n        begin: '<!DOCTYPE', end: '>',\n        relevance: 10,\n        contains: [{begin: '\\\\[', end: '\\\\]'}]\n      },\n      {\n        className: 'comment',\n        begin: '<!--', end: '-->',\n        relevance: 10\n      },\n      {\n        className: 'cdata',\n        begin: '<\\\\!\\\\[CDATA\\\\[', end: '\\\\]\\\\]>',\n        relevance: 10\n      },\n      {\n        className: 'tag',\n        /*\n        The lookahead pattern (?=...) ensures that 'begin' only matches\n        '<style' as a single word, followed by a whitespace or an\n        ending braket. The '$' is needed for the lexeme to be recognized\n        by hljs.subMode() that tests lexemes outside the stream.\n        */\n        begin: '<style(?=\\\\s|>|$)', end: '>',\n        keywords: {title: 'style'},\n        contains: [TAG_INTERNALS],\n        starts: {\n          end: '</style>', returnEnd: true,\n          subLanguage: 'css'\n        }\n      },\n      {\n        className: 'tag',\n        // See the comment in the <style tag about the lookahead pattern\n        begin: '<script(?=\\\\s|>|$)', end: '>',\n        keywords: {title: 'script'},\n        contains: [TAG_INTERNALS],\n        starts: {\n          end: '</script>', returnEnd: true,\n          subLanguage: 'javascript'\n        }\n      },\n      PHP,\n      {\n        className: 'pi',\n        begin: /<\\?\\w+/, end: /\\?>/,\n        relevance: 10\n      },\n      {\n        className: 'tag',\n        begin: '</?', end: '/?>',\n        contains: [\n          {\n            className: 'title', begin: /[^ \\/><\\n\\t]+/, relevance: 0\n          },\n          TAG_INTERNALS\n        ]\n      }\n    ]\n  };\n};",

"highlight_javascript.js":"module.exports = function(hljs) {\n  return {\n    aliases: ['js'],\n    keywords: {\n      keyword:\n        'in if for while finally var new function do return void else break catch ' +\n        'instanceof with throw case default try this switch continue typeof delete ' +\n        'let yield const class',\n      literal:\n        'true false null undefined NaN Infinity',\n      built_in:\n        'eval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent ' +\n        'encodeURI encodeURIComponent escape unescape Object Function Boolean Error ' +\n        'EvalError InternalError RangeError ReferenceError StopIteration SyntaxError ' +\n        'TypeError URIError Number Math Date String RegExp Array Float32Array ' +\n        'Float64Array Int16Array Int32Array Int8Array Uint16Array Uint32Array ' +\n        'Uint8Array Uint8ClampedArray ArrayBuffer DataView JSON Intl arguments require ' +\n        'module console window document'\n    },\n    contains: [\n      {\n        className: 'pi',\n        relevance: 10,\n        variants: [\n          {begin: /^\\s*('|\")use strict('|\")/},\n          {begin: /^\\s*('|\")use asm('|\")/}\n        ]\n      },\n      hljs.APOS_STRING_MODE,\n      hljs.QUOTE_STRING_MODE,\n      hljs.C_LINE_COMMENT_MODE,\n      hljs.C_BLOCK_COMMENT_MODE,\n      hljs.C_NUMBER_MODE,\n      { // \"value\" container\n        begin: '(' + hljs.RE_STARTERS_RE + '|\\\\b(case|return|throw)\\\\b)\\\\s*',\n        keywords: 'return throw case',\n        contains: [\n          hljs.C_LINE_COMMENT_MODE,\n          hljs.C_BLOCK_COMMENT_MODE,\n          hljs.REGEXP_MODE,\n          { // E4X\n            begin: /</, end: />;/,\n            relevance: 0,\n            subLanguage: 'xml'\n          }\n        ],\n        relevance: 0\n      },\n      {\n        className: 'function',\n        beginKeywords: 'function', end: /\\{/, excludeEnd: true,\n        contains: [\n          hljs.inherit(hljs.TITLE_MODE, {begin: /[A-Za-z$_][0-9A-Za-z$_]*/}),\n          {\n            className: 'params',\n            begin: /\\(/, end: /\\)/,\n            contains: [\n              hljs.C_LINE_COMMENT_MODE,\n              hljs.C_BLOCK_COMMENT_MODE\n            ],\n            illegal: /[\"'\\(]/\n          }\n        ],\n        illegal: /\\[|%/\n      },\n      {\n        begin: /\\$[(.]/ // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`\n      },\n      {\n        begin: '\\\\.' + hljs.IDENT_RE, relevance: 0 // hack: prevents detection of keywords after dots\n      }\n    ]\n  };\n};",

"highlight_json.js":"module.exports = function(hljs) {\n  var LITERALS = {literal: 'true false null'};\n  var TYPES = [\n    hljs.QUOTE_STRING_MODE,\n    hljs.C_NUMBER_MODE\n  ];\n  var VALUE_CONTAINER = {\n    className: 'value',\n    end: ',', endsWithParent: true, excludeEnd: true,\n    contains: TYPES,\n    keywords: LITERALS\n  };\n  var OBJECT = {\n    begin: '{', end: '}',\n    contains: [\n      {\n        className: 'attribute',\n        begin: '\\\\s*\"', end: '\"\\\\s*:\\\\s*', excludeBegin: true, excludeEnd: true,\n        contains: [hljs.BACKSLASH_ESCAPE],\n        illegal: '\\\\n',\n        starts: VALUE_CONTAINER\n      }\n    ],\n    illegal: '\\\\S'\n  };\n  var ARRAY = {\n    begin: '\\\\[', end: '\\\\]',\n    contains: [hljs.inherit(VALUE_CONTAINER, {className: null})], // inherit is also a workaround for a bug that makes shared modes with endsWithParent compile only the ending of one of the parents\n    illegal: '\\\\S'\n  };\n  TYPES.splice(TYPES.length, 0, OBJECT, ARRAY);\n  return {\n    contains: TYPES,\n    keywords: LITERALS,\n    illegal: '\\\\S'\n  };\n};",

"highlight_css.js":"module.exports = function(hljs) {\n  var IDENT_RE = '[a-zA-Z-][a-zA-Z0-9_-]*';\n  var FUNCTION = {\n    className: 'function',\n    begin: IDENT_RE + '\\\\(',\n    returnBegin: true,\n    excludeEnd: true,\n    end: '\\\\('\n  };\n  return {\n    case_insensitive: true,\n    illegal: '[=/|\\']',\n    contains: [\n      hljs.C_BLOCK_COMMENT_MODE,\n      {\n        className: 'id', begin: '\\\\#[A-Za-z0-9_-]+'\n      },\n      {\n        className: 'class', begin: '\\\\.[A-Za-z0-9_-]+',\n        relevance: 0\n      },\n      {\n        className: 'attr_selector',\n        begin: '\\\\[', end: '\\\\]',\n        illegal: '$'\n      },\n      {\n        className: 'pseudo',\n        begin: ':(:)?[a-zA-Z0-9\\\\_\\\\-\\\\+\\\\(\\\\)\\\\\"\\\\\\']+'\n      },\n      {\n        className: 'at_rule',\n        begin: '@(font-face|page)',\n        lexemes: '[a-z-]+',\n        keywords: 'font-face page'\n      },\n      {\n        className: 'at_rule',\n        begin: '@', end: '[{;]', // at_rule eating first \"{\" is a good thing\n                                 // because it doesn’t let it to be parsed as\n                                 // a rule set but instead drops parser into\n                                 // the default mode which is how it should be.\n        contains: [\n          {\n            className: 'keyword',\n            begin: /\\S+/\n          },\n          {\n            begin: /\\s/, endsWithParent: true, excludeEnd: true,\n            relevance: 0,\n            contains: [\n              FUNCTION,\n              hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE,\n              hljs.CSS_NUMBER_MODE\n            ]\n          }\n        ]\n      },\n      {\n        className: 'tag', begin: IDENT_RE,\n        relevance: 0\n      },\n      {\n        className: 'rules',\n        begin: '{', end: '}',\n        illegal: '[^\\\\s]',\n        relevance: 0,\n        contains: [\n          hljs.C_BLOCK_COMMENT_MODE,\n          {\n            className: 'rule',\n            begin: '[^\\\\s]', returnBegin: true, end: ';', endsWithParent: true,\n            contains: [\n              {\n                className: 'attribute',\n                begin: '[A-Z\\\\_\\\\.\\\\-]+', end: ':',\n                excludeEnd: true,\n                illegal: '[^\\\\s]',\n                starts: {\n                  className: 'value',\n                  endsWithParent: true, excludeEnd: true,\n                  contains: [\n                    FUNCTION,\n                    hljs.CSS_NUMBER_MODE,\n                    hljs.QUOTE_STRING_MODE,\n                    hljs.APOS_STRING_MODE,\n                    hljs.C_BLOCK_COMMENT_MODE,\n                    {\n                      className: 'hexcolor', begin: '#[0-9A-Fa-f]+'\n                    },\n                    {\n                      className: 'important', begin: '!important'\n                    }\n                  ]\n                }\n              }\n            ]\n          }\n        ]\n      }\n    ]\n  };\n};",

"highlight_markdown.js":"module.exports = function(hljs) {\n  return {\n    aliases: ['md', 'mkdown', 'mkd'],\n    contains: [\n      // highlight headers\n      {\n        className: 'header',\n        variants: [\n          { begin: '^#{1,6}', end: '$' },\n          { begin: '^.+?\\\\n[=-]{2,}$' }\n        ]\n      },\n      // inline html\n      {\n        begin: '<', end: '>',\n        subLanguage: 'xml',\n        relevance: 0\n      },\n      // lists (indicators only)\n      {\n        className: 'bullet',\n        begin: '^([*+-]|(\\\\d+\\\\.))\\\\s+'\n      },\n      // strong segments\n      {\n        className: 'strong',\n        begin: '[*_]{2}.+?[*_]{2}'\n      },\n      // emphasis segments\n      {\n        className: 'emphasis',\n        variants: [\n          { begin: '\\\\*.+?\\\\*' },\n          { begin: '_.+?_'\n          , relevance: 0\n          }\n        ]\n      },\n      // blockquotes\n      {\n        className: 'blockquote',\n        begin: '^>\\\\s+', end: '$'\n      },\n      // code snippets\n      {\n        className: 'code',\n        variants: [\n          { begin: '`.+?`' },\n          { begin: '^( {4}|\\t)', end: '$'\n          , relevance: 0\n          }\n        ]\n      },\n      // horizontal rules\n      {\n        className: 'horizontal_rule',\n        begin: '^[-\\\\*]{3,}', end: '$'\n      },\n      // using links - title and link\n      {\n        begin: '\\\\[.+?\\\\][\\\\(\\\\[].*?[\\\\)\\\\]]',\n        returnBegin: true,\n        contains: [\n          {\n            className: 'link_label',\n            begin: '\\\\[', end: '\\\\]',\n            excludeBegin: true,\n            returnEnd: true,\n            relevance: 0\n          },\n          {\n            className: 'link_url',\n            begin: '\\\\]\\\\(', end: '\\\\)',\n            excludeBegin: true, excludeEnd: true\n          },\n          {\n            className: 'link_reference',\n            begin: '\\\\]\\\\[', end: '\\\\]',\n            excludeBegin: true, excludeEnd: true\n          }\n        ],\n        relevance: 10\n      },\n      {\n        begin: '^\\\\[\\.+\\\\]:',\n        returnBegin: true,\n        contains: [\n          {\n            className: 'link_reference',\n            begin: '\\\\[', end: '\\\\]:',\n            excludeBegin: true, excludeEnd: true,\n            starts: {\n              className: 'link_url',\n              end: '$'\n            }\n          }\n        ]\n      }\n    ]\n  };\n};",

"README.md":"# Introduction\n\n[CouchDB](http://couchdb.apache.org) a database management system server\nthat use HTTP and HTTPS protocols\nprimarily to deliver `JSON` documents.\n[CouchApp](http://docs.couchdb.org/en/latest/couchapp) a client-server application framework based\non a Web browser front-end and a `CouchDB` back-end.\n\n`pry` is a `CouchApp` that manages literate\nprograms on `CouchDB`. It uses [markover](http://cygnyx.github.io/markover)\nto 'tangle' a `markdown` document into a `CouchApp` and 'weave' it into\na `HTML` document.\nFrom the same [README.md](README.md), it produces a [README.json](README.json) \nand a [README.html](README.html). `CouchDB` delivers a [design document](.)\nthat is very similar to the `README.json` file.\n\n`pry` itself has a small API: for the source README and the derived `JSON` and\n`HTML` versions.\nIn addition it implements an [editor](editor).\nThe editor optionally takes a `id` argument with a path to the source\ndocument.\n\n`pry` is a rudimentry deployment tool along the lines of\n[Kanso](http://kan.so), [couchapp](https://github.com/couchapp/couchapp), or\n[capp](https://github.com/nick-thompson/capp).\n\n`pry` doesn't support attachments to documents. It only supports the creation\nof a `JSON` object (or document) which is deployed to the `CouchDB`.\nBy convention, the source document is called `README.md` and it is included\nin the `JSON` document.\nThis might be a little confusing at first.\nThe important point is that you shouldn't create a `JSON` document with a\nfield named `README.md` since this will be used by `pry` to store the source\ndocument (but it is possible to use a different field name).\n\nBy default, `pry` operates on itself. In the editor, it will download the\nsource document (in the `README.md` field) into a browser-based editor.\nYou can modify `pry`, changing its documentation or source code in the editor.\nBy changing the `_id` of the document, you can upload it to a different location.\nYou can change the database used as well in the editor.\n\nUsing the `id` parameter, `pry` will edit another source document\nby downloading its source document (in the `README.md` field) into the editor.\n\nFor example, after opening the `pry` editor you can replace its contents with:\n\n    ```#+_id\n    foo\n    ```\n    \n    ```#+history\n    It is derived from fubar.\n    ```\n\nand upload this document. The resulting `JSON` object will have 3 fields: `_id`,\n`history`, and `README.md`. In the editor, these fields are visible in the `Source Code`\ntab. Then you can edit this document by passing in `?id=example/foo`.\nRecall that `markover` uses a `+` (plus sign) to indicate that a field should be quoted.\nYou can create a new document by renaming the `_id` field to `bar` and uploading.\n\nYou can change the source document name using the option `md` to the editor.\nFor example, `?md=READMEFIRST.md` would look for the `READMEFIRST.md` field for\nthe source document.\n\n```noweave#+title\npry\n```\n\n```noweave#+tag\nCouchApp Literate Programming\n```\n\n```noweave#+version\n0.0.1\n```\n\n# CouchDB fields\n\nThere is only one field that is require in CouchDB for every document: _id.\nThis is the identifier that the JSON document is addressed by.\nIn this case, `pry` is a design document:\n\n```#+_id\n_design/pry\n```\n\n# CouchApp fields\n\nThere are many optional fields used by a `CouchApp`, but\n`pry` is only using two fields: `rewrites` and `shows`.\n\nRewrites are used to translate nice URLs into the URLs used internally.\nThey are particularly useful when combined with a virtual host.\nFor example, by creating a DNS for 'example', `CouchDB` can be\nconfigured to use the path '/example/_design/pry/_rewrite'.\nThen URLs like 'http://example/README.html' are translated to\n'http://example/example/_design/pry/_rewrite/README.html'.\nNote that it is difficult to use `pry` with virtually hosts.\nYou are better off using the real hostname.\n\nThis represents the entire API for `pry`.\n\n```#rewrites\n[\n   {\n       \"from\": \"\",\n       \"to\": \".\"\n   },\n   {\n       \"from\": \"/README.html\",\n       \"to\": \"_show/README.html\"\n   },\n   {\n       \"from\": \"/README.md\",\n       \"to\": \"_show/README.md\"\n   },\n   {\n       \"from\": \"/README.json\",\n       \"to\": \"_show/README.json\"\n   },\n   {\n       \"from\": \"editor\",\n       \"to\": \"_show/editor\"\n   },\n   {\n       \"from\": \"*\",\n       \"to\": \"_show/404\"\n   }\n]\n```\n\nThe first URL returns a `JSON` object of the `pry` design document.\nThe other URLs are converted into show function calls.\n\nCouchApps have limited support for javascript.\nThe `shows` object is one of the places where you can embed\nanonymous javascript functions in a string.\nEach function has 2 arguments: the document and the request.\nSince they are embedded in strings it is easier to implement\nthe details in another functions.\nBut the other functions must be contained within a `CommonJS` module.\nIn this case the module 'main' is used.\nThese anonymous rewrite functions tend to be one-liners.\n\n```#shows\n{\n   \"404\": \"function(doc, req){ return {body: '<h1>404 - Document not found</h1>\\\\n'}, headers: {'Content-Type': 'text/html'}}}\",\n   \"editor\": \"function(doc, req){ return {body: require('main').edit.call(this, req), headers: {'Content-Type': 'text/html'}}}\",\n   \"README.md\": \"function(doc, req){ return {body: this['README.md'], headers: {'Content-Type': 'text/markdown'}}}\",\n   \"README.html\": \"function(doc, req){ return {body: require('main').weave.call(this), headers: {'Content-Type': 'text/html'}}}\",\n   \"README.json\": \"function(doc, req){ return {body: require('main').tangle.call(this), headers: {'Content-Type': 'text/plain'}}}\"\n}\n```\n\n# Program Structure\n\n`pry` relies on `markover` for document processing, which relies on `marked`\nand `highlight.js`. The editor in `pry` is implemented in the Web browser (of course).\nSo there are some challenges to constructing an application (`pry`) in the CouchDB environment\nthat will serve up another application (the editor) in the Web browser environment.\nThe main issues revolve around special characters and strings that are not allowed\nin certain situations.\n\n# Editor\n\nThe `pry` editor is a meta-level HTML document. That is, in this document\nwe are writing the code that will delivered to the Web browser that will\nprovide the editor for the document.\n\n## HTML layout\n\nThe editor is an HTML document with 4 tabs.\n\n```js#+editorcontent\n<ul class='tabs'>\n  <li><a href='#tab1'>Document</a></li>\n  <li><a href='#tab2'>Source Code</a></li>\n  <li><a href='#tab3'>HTML</a></li>\n  <li><a href='#tab4'>Update</a></li>\n</ul>\n\n<div class='display'>\n<div id='tab1'><input type=\"text\" id='_src' value=''></input><textarea id='_editor'></textarea></div>\n<div id='tab2'><div id='_code'></div></div>\n<div id='tab3'></div>\n<div id='tab4'></div>\n</div>\n```\n\n## Editor stylesheet\n\nThe editor needs its own stylesheet.\n\nFirst, reset the stylesheet.\n\n```css#+editorstyle\nhtml, body, div, span, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre,\nabbr, address, cite, code, del, dfn, em, img, ins, kbd, q, samp,\nsmall, strong, sub, sup, var, b, i, dl, dt, dd, ol, ul, li, a, textarea, input,\nfieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td,\narticle, aside, canvas, details, figcaption, figure,\nfooter, header, hgroup, menu, nav, section, summary, time, mark, audio, video {\n  display: block;\n  margin: 0;\n  padding: 0;\n  border: 0;\n  outline: 0;\n  line-height: 140%;\n  font-size: inherit;\n  color: black;\n  vertical-align: baseline;\n  text-decoration: none;\n  background: transparent;\n}\n\na, code, span, b, i, em { display: inline; }\n\nbody {\n  font-size: 100%;\n}\n```\n\nHighlight active elements in the interface.\n\n```css#+editorstyle\n#tab1 #_src, #tab1 #_editor, .tabs li {\n  border: solid black 1px;\n}\n\n.tabs li:hover, #tab1 #_editor:focus, #tab1 #_src:focus {\n  border: solid orange 1px;\n}\n```\n\nFor the coding environment, use a monospace type.\nSet up the tabs with the same margins.\n\n```css#+editorstyle\n.display, .tabs {\n  margin: 0.4em;\n}\n\n#tab1 #_editor, #tab1 #_src {\n  width: 99%;\n  font-family: Courier, monospace;\n  padding: 0.5%;\n}\n\n#tab1 #_editor {\n  resize: none;\n  height: 40em;\n}\n```\n\nConfigure the layout of the menu.\n\n```css#+editorstyle\n.tabs li {\n  list-style: none;\n  display: inline;\n  padding: 0.4em;\n}\n\n.tabs a, .tabs input {\n  display: inline-block;\n  color: gray;\n}\n\n.tabs a.active {\n  color: black;\n}\n```\n\nFor the source code tab show the formatted output.\n\n```css#+editorstyle\n.display #_code {\n  white-space: pre;\n  overflow: visible;\n  word-wrap: break-word;\n}\n```\n\nHide the menu when printing.\n\n```css#+editorstyle\n\n@media print {\n  .tabs {\n    display: none;\n  }\n}\n```\n\n## The Editor javascript\n\nAfter the document is loaded, insert the source into the editor\nand configure the tabs.\nThe source location is initialized as an absolute path on\nthe couchdb host, not a virtual host.\n\nTangle and weave can take a significant amount of time.\nThe `longwait` function is called after the document is modified\nand the user has stopped typing. In the first pass it handles\nthe 2nd tab and in the second pass it handles the 3rd tab.\nA short timeout is used between passes to allow for user\ninteractions to update. Perhaps this could be implemented in a\nworker process instead of the main thread. The delay time\nis estimated from the previous runtime.\n\n```js#+editorscript\nvar tab2todo = true\n\nfunction longwait() {\n  var st = new Date()\n  if (tab2todo) {\n    setuptab2()\n    this.timeout = setTimeout(longwait, 50)\n  } else {\n    setuptab3()\n  }\n  tab2todo = !tab2todo\n  var ms = new Date() - st\n  if (ms < 500) ms = 500\n  this.delay = 2 * ms\n}\n```\n\nGetting and putting documents happens asynchronously.\nUsually the time gaps are not too significant between\nthe request and the delivery of a result.\n\nWhen the document is available `putDoc1` initializes\nthe editor. `putDoc` is called when the document has\nbeen delivered.\n\n```js#+editorscript\nfunction putDoc1(md) {\n  $(\"#_editor\").text(md)\n  setuptab1()\n  this.timeout = setTimeout(longwait, 50)\n}\n\nfunction putDoc(errflag, md) {\n  if (errflag)\n    md = ''\n  else\n    md = md[mdref]\n  putDoc1(md)\n}\n```\n\n`makeurl` adds server location information to a path.\n\n```js#+editorscript\nfunction makeurl(path) {\n  return location.protocol + '//' + location.host + '/' + path\n}\n```\n\nThis is called when the document is loaded.\nIt installs a timeout on the keyup event in the editor,\nrecords the path to the source document,\nand gets the source document.\nThe source document is either pre-downloaded or\nwe have to get it.\n\n```js#+editorscript\n$(document).ready(function () {\n  $(\"#_editor\").keyup(function() {\n    if (this.timeout) clearTimeout(this.timeout)\n    tab2todo = true\n    this.timeout = setTimeout(longwait, this.delay || 1000)\n  })\n  $(\"#_src\").val(mddb)\n  markover = require('markover')\n\n  if (typeof md == \"undefined\") {\n    var url = makeurl(mddb)\n    getDocument(url, putDoc)\n  } else\n    putDoc1(md)\n}) \n```\n\nIn HTML documents the processing of '&' and '<' characters is tricky.\nThis function handles HTML escapes codes.\n\n```js#+editorscript\nfunction escape(str) {\n  return str\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n}\n```\n\nTangle the HTML editor element\n\n```js#+editorscript\nvar markover\n\nfunction tangleDoc() {\n  var src = $('#_editor')[0].value\n  var el = $('#_code')\n  var res\n  if (typeof mdref == \"undefined\" || mdref == \"\")\n    res = markover.tangleJSON(src)\n  else\n    res = markover.tangleJSON(src, {sourcetarget: mdref})\n  return res\n}\n```\n\nFunctions to set up the tabs.\n\n```js#+editorscript\nfunction setuptab1() {\n  $(\"#_editor\")[0].focus()\n}\n\nfunction setuptab2() {\n  var el = $('#_code')\n  var txt = tangleDoc()\n  el.text(txt)\n}\n\nfunction setuptab3() {\n  var src = $('#_editor')[0].value\n  var el = $('#tab3')\n  var txt = markover.weaveJSON(src, {contentonly: true})\n  el.html(txt)\n}\n\nfunction setuptab4() {\n  var src = $('#_editor')[0].value\n  var url = $('#_src')[0].value.split('/')\n  url = url[0]\n  var txt = tangleDoc()\n  var json = JSON.parse(txt)\n  var id = json._id\n  json[mdref] = src\n  url = [url, id].join('/')\n  $('#tab4').html('</h1>Updating ' + id + '</h1>')\n  url = makeurl(url)\n  updatedoc(url, json)\n}\n\nvar editfunction = {\n  tab1: function(){setuptab1()},\n  tab4: function(){setuptab4()}\n}\n```\n\nSet up the menus to show the active tab.\nInstall the onclick event handler to switch tabs.\n\n```js#+editorscript\n$('ul.tabs').each(function() {\n  var active, content, links = $(this).find('a'), inputs = $(this).find('input')\n\n  active = $(links[0])\n  active.addClass('active')\n\n  content = $(active[0].hash)\n\n  links.not(active).each(function () {\n    $(this.hash).hide()\n  })\n\n  $(this).on('click', 'a', function(e){\n    active.removeClass('active')\n    content.hide()\n\n    active = $(this)\n    content = $(this.hash)\n\n    active.addClass('active')\n\n    var f = editfunction[this.hash.substring(1)]\n    if (typeof f !== \"undefined\") {\n       f()\n    }\n    content.show()\n\n    e.preventDefault()\n  })\n})\n```\n\nQuick and dirty implementation of `CommonJS` `require` function.\nIf a `name` has been loaded, it is returned.\nThe loading of the modules is described below.\n\n```js#+editorscript\nvar require = function require(name) {\n  if (require.loaded[name])\n    return require.loaded[name]\n  throw new Error(\"module missing:\" + name)\n}\nrequire.loaded = {}\n```\n\n## Update document\n\nBefore a document can be updated, the revision\nof the current document is needed.\n\nPerhaps the revision could be reported by the server,\nbut for now we simply get the current version from the server.\n\nThis function gets a document from a CouchDB server\nand calls the callback function with the errflag,\nthe JSON response, the URL and some other data.\n\n```js#+editorscript\nfunction getDocument(url, cb, data) {\n  $.ajax({\n    url: url,\n    dataType: 'json'\n  })\n  .done(function(d, s, x) {\n    cb(false, x.responseJSON, url, data)\n  })\n  .fail(function(x, s, e) {\n    cb(true, x.responseJSON, url, data)\n  })\n}\n```\n\nSimilarly, this function puts a document to a CouchDB server,\ncalling the callback function with the errflag, and the JSON response.\n\n```js#+editorscript\nfunction putDocument(url, doc, cb) {\n  $.ajax({\n    url: url,\n    type: 'PUT',\n    data: JSON.stringify(doc),\n    contentType: 'application/json',\n    dataType: 'json'\n  })\n  .done(function(d, s, x) {\n    cb(false, x.responseJSON)\n  })\n  .fail(function(x, s, e) {\n    cb(true, x.responseJSON)\n  })\n}\n```\n\nUpdating a document happens through a series of\nasynchronous calls. The first step is to get the\ncurrent version of the document.\n\n```js#+editorscript\nfunction updatedoc(url, json) {\n  getDocument(url, updatedoc1, json)\n}\n```\n\nIf there isn't a current document, assume that\na new document is being created, otherwise\nadd the revision number to the new version of\nthe document.\n\n```js#+editorscript\nfunction updatedoc1(errflag, resp, url, doc) {\n  var rev\n  var doit = false\n  var err\n  if (errflag) {\n    if (resp) {\n      err = resp.error\n      doit = resp.error == \"not_found\"\n    } else {\n      doit = true\n    }\n  } else {\n    doit = true\n    doc._rev = resp._rev\n  }\n  if (!doit)\n    $('#tab4').html('</h1>Update Error: ' + (err || \"unknown\") + '</h1>')\n  else {\n    $('#tab4').html('</h1>Updating ' + url + '</h1>')\n    putDocument(url, doc, updatedocwithrev)\n  }\n}\n```\n\nNow the put worked or it didn't. Report the result.\n\n```js#+editorscript\nfunction updatedocwithrev(errflag, doc) {\n  if (errflag)\n    $('#tab4').html('</h1>Update Error: ' + \"unknown\" + '</h1>')\n  else\n    $('#tab4').html('</h1>Updated ' + doc.id + ' to revision ' + doc.rev + '</h1>')\n}\n```\n\n## Main module\n\nThe main module implements the functionality of `pry`.\n\n```js#+main\n!(function() {\n\nvar markover = require('markover')\n\nvar main = {\n```\n\nFirst tangle and weave are handled.\nThese operations happen on the server side\nand are unrelated to the editor.\n\n```js#+main\n  weave: function () {\n    return markover.weaveJSON(this['README.md'])\n  },\n  tangle: function() {\n    return markover.tangleJSON(this['README.md'], {sourcetarget: 'README.md'})\n  },\n```\n\nThe '</script>' tag needs special handling here. It isn't allowed inside a string\nwithin a javascript block. \nThe 'fixup' function replaces '</script>' with '<&#' and '47;script>' combined,\nbut the script block delimiters\nin the 'edit' function should *not* be replaced, and they use '</'+'script>'.\n\n```js#+main\n  fixup: function(str) {\n    return str.replace(/<\\/script>/gm, '<&#'+'47;script>')\n  },\n```\n\nRegular multiline text is encoded in JSON strings.\nSpecial characters are mapped to escape codes.\n\n```js#+main\n  quotestring: function(code) {\n    return ('\"' +\n      code\n        .replace(/\\\\/gm, '\\\\\\\\')\n        .replace(/\\\"/gm /*\"*/, '\\\\\"')\n        .replace(/\\n/gm , '\\\\n')\n        .replace(/\\t/gm , '\\\\t')\n      + '\"')\n  },\n```\n\nProduce the HTML edit document.\nFirst get the encoded source document.\nNote that 'fixup' runs on this document,\nso any reference to '</script>' must be handled with care.\n\n```js#+main\n  edit: function(req) {\n    var mdref = 'README.md'\n    var p = req.path\n    var mddb = p.slice(0,3).join('/')\n    var src\n    if (req.query.md) {\n      mdref = req.query.md\n    }\n    if (req.query.id) {\n      mddb = req.query.id\n    } else\n      src = main.quotestring(main.fixup(this[mdref]))\n    var buf = []\n```\n\nThe editor header material\n\n```js#+edithead\n<!DOCTYPE html><html><head>\n<meta charset=\"utf-8\">\n<meta http-equiv=\"Content-Language\" content=\"en\">\n<meta name=\"viewport\" content=\"initial-scale=1\">\n<title>Editor</title>\n<style>\n```\n\nPush the header material, the style and\nadditional script references.\nNote the handling of the </script> tag.\n\n```js#+main\n    buf.push(this.edithead)\n    buf.push(this.editorstyle)\n    buf.push('</style>'); // syntax help\n\n    ['https://code.jquery.com/jquery-2.1.3.min.js'].forEach(function(e){\n      buf.push('<script type=\"text/javascript\" src=\"'+e+'\"></'+'script>')\n    })\n\n    buf.push(\"</head><body>\")\n    buf.push(this.editorcontent)\n    buf.push(\"</body></html>\")\n```\n\nAfter the document the on-the-fly script is included.\nFirst record the location of the source document, its contents\nand the basic edit scripts.\n\n```js#+main\n    buf.push('<script type=\"text/javascript\">')\n    buf.push('var mdref = \"' + mdref + '\"')\n    buf.push('var mddb = \"' + mddb + '\"')\n    buf.push('var md ' + (src ? (' = ' + src) : ''))\n    buf.push(this.editorscript)\n    var self = this\n```\n\nThis is my quick and dirty implementation of pre-loaded `CommonJS`\nmodules.\nThe modules are assumed to exist in the design document, `self`.\nAn initial list of modules is set in `incs`.\nFor each module, check if it hasn't been loaded.\nIf not, then statically scan the module code and push\nany dependent modules onto `incs`.\nModule names and contents are pushed into `mods`\n\n```js#+main\n    var incs = [\"markover\"]\n    var e\n    var r\n    var i\n    var exports = {}\n    var mods = []\n\n    for(i = 0; i < incs.length; i++) {\n      e = incs[i]\n      if (exports[e] == undefined && self[e] != undefined) {\n        main.scanrequire(incs, self[e])\n        if (self[e] != null) {\n          mods.push([e, self[e]])\n          exports[e] = true\n        }\n      }\n    }\n```\n\nProcess `mods` in reverse order. All dependent modules\nshould be loaded before the requiring module.\nInitialize a empty `module` and `exports`.\nWrap the module code in a function with arguments\nof `module`, `exports`, and `require`.\nCall the wrap function with the prepared arguments.\nCheck for non-empty results and store it in `loaded`.\nClean up temporary objects.\n\nThis should work for modules that are not mutually dependent.\n\nAn alternative implementation would be to put a default value\nfor all modules that are in `mods` into require.loaded and\nthen update the values as they get loaded. May be the default\nvalue would be a function that would return the real object\nafter it has actually been loaded.\n\n```js#+main\n    i = mods.length\n    while ( (--i) >= 0) {\n      e = mods[i][0]\n      r = mods[i][1]\n      buf.push('require.module = {}')\n      buf.push('require.exports = {}')\n      buf.push(\"require.loading = function (module, exports, require) {\")\n      buf.push(main.fixup(r))\n      buf.push(\"}\")\n      buf.push(\"require.loading(require.module, require.exports, require)\")\n      buf.push('if (typeof require.module.exports == \"undefined\") require.module.exports = require.exports')\n      buf.push('require.loaded[\"' + e + '\"] = require.module.exports')\n      buf.push('delete require.module.exports')\n    }\n```\n\nThe final step is some clean and closing the script.\nNote the '</script>' handling.\n\n```js#+main\n    buf.push('delete require.loading')\n    buf.push('delete require.module')\n    buf.push('delete require.exports')\n    buf.push('</'+'script>')\n    buf.push(\"\")\n    return buf.join('\\n')\n  },\n```\n\n`scanrequire` statically looks for module names\n\n```js#+main\n  scanrequire: function(incs, str) {\n    var m = str.match(/require\\(['\"]([^'\"]*)['\"]\\)/gm)\n    if (m != null) {\n      m.forEach(function(e) {\n        var name = e.substring(9,e.length-2)\n        if (incs.indexOf(name) == -1)\n          incs.push(name)\n      })\n    }\n  }\n```\n\nNow, export the editor module\n\n```js#+main\n}\n\nmodule.exports = main\n\n}).call(function () {\n        return this || (typeof window !== 'undefined' ? window : global)\n})\n```\n\n# HTML layout\n\nThis HTML layout is used for the weave document.\nHere is the typical start of an HTML document.\n\n```html#+head\n<!DOCTYPE html>\n<html lang=\"en\" class=\"\">\n<head>\n```\n\nThese meta lines might help.\n\n```html#+head\n  <meta charset=\"utf-8\">\n  <meta http-equiv=\"Content-Language\" content=\"en\">\n  <meta name=\"viewport\" content=\"initial-scale=1\">\n```\n\nAnd the transition from head to body\n\n```html#+transition\n</head>\n<body>\n```\n\nTail end\n\n```html#+tail\n</body>\n</html>\n```\n\n# HTML stylesheet\n\nMake the formatted README look a little smarter:\n\n## Vanilla style\n\nThis first section resets all `HTML` elements to reasonable default values.\n\n```css#+headstylesheet\nhtml, body, div, span, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre,\nabbr, address, cite, code, del, dfn, em, img, ins, kbd, q, samp,\nsmall, strong, sub, sup, var, b, i, dl, dt, dd, ol, ul, li, a,\nfieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td,\narticle, aside, canvas, details, figcaption, figure,\nfooter, header, hgroup, menu, nav, section, summary, time, mark, audio, video {\n  display: block;\n  margin:0;\n  padding:0;\n  border:0;\n  outline:0;\n  line-height: 140%;\n  font-size: inherit;\n  color: black;\n  vertical-align:baseline;\n  text-decoration: none;\n  background:transparent;\n}\n\na, code, span, b, i, em { display: inline; }\n\nbody {\n  font-size: 100%;\n}\n\n@media print {\n  body {\n    font-size: 80%;\n  }\n}\n```\n\n## Preliminary Material\n\nThe following stylesheet operates within the content generated by applying `weave`\nto the source document.\n`markover` marks up 3 areas before the main document body:\ntitle, tag, and a table of contents.\n\nTitle and tag are each in a single id and only appear once in the display document.\n\n```css#+stylesheet\n#content {\n  font-family: \"HelveticaNeue-Light\", \"Helvetica Neue Light\", \"Helvetica Neue\", Helvetica, Arial, \"Lucida Grande\", sans-serif; \n}\n\n#content #title {\n  clear: both;\n  text-align: center;\n  font-size: 140%;\n  font-weight: bold;\n  margin: 2em 0 0 0;\n}\n\n#content #tag {\n  clear: both;\n  text-align: center;\n  font-size: 110%;\n  margin: 0 0 1em 0;\n}\n```\n\nThe table of contents, in a single `toc` id, is slightly more complex.\n\n```css#+stylesheet\n#content #toc {\n  padding: 0 0 0 1em;\n  max-width: 96%;\n  page-break-after: always;\n}\n\n@media screen and (min-width: 641px) {\n  #content #toc {\n    float: left;\n    max-width: 26%;\n  }\n}\n\n#content .tocsn {\n  float: left;\n}\n\n#content .tocsr {\n  overflow: hidden;\n}\n\n#content #toc ol {\n  list-style-type: none;\n}\n\n#content #toc ol ol {\n  margin: 0 0 0 1em;\n}\n```\n\n## Main body\n\nThe main document is in a single `doc` id\nMake the toc and doc with the same margins.\n\n```css#+stylesheet\n#content #doc,\n#content #toc {\n  margin: 0 1em 0 1em;\n}\n\n#content p { text-indent: 1em; }\n\n#content code { font-size: 120%; }\n\n#content pre code {\n  font-family: \"Courier New\", Courier, monospace;\n  font-size: 100%;\n}\n\n@media screen and (min-width: 641px) {\n  #content #doc {\n    overflow: hidden;\n    max-width: 70%;\n  }\n}\n```\n\nField names are in a `field` class.\n\n```css#+stylesheet\n#content pre .field {\n  display:block;\n  margin: 1em 1em 0em 0em;\n}\n \n#content pre .field::after {\n  content: \" :=\";\n}\n```\n\nThe code blocks are in the `code` tag and\nhave classes that identify their language.\n\n```css#+stylesheet\n#content pre code {\n  display: block;\n  margin: 1em;\n  padding: 1em;\n  border: solid 1px #aaa;\n}\n\n@media screen {\n  #content pre code {\n    background-color: AliceBlue;\n    overflow: auto;\n    max-height: 30em;\n  }\n}\n\n@media print {\n  #content pre {\n    page-break-inside: avoid;\n  }\n  #content pre code {\n    overflow: visible;\n    word-wrap: break-word;\n  }\n}\n```\n\nEach language uses a slightly different light background color.\n\n```css#+stylesheet\n@media screen {\n  #content .lang-js { background-color: ivory; }\n  #content .lang-md { background-color: lightyellow; }\n  #content .lang-html { background-color: floralwhite; }\n  #content .lang-json { background-color: honeydew; }\n  #content .lang-css { background-color: cornsilk; }\n  #content .lang-sh { background-color: lemonchiffon; }\n}\n```\n\nThe header font sizes are set.\n\n```css#+stylesheet\n#content h1,\n#content h2,\n#content h3,\n#content h4,\n#content h5,\n#content h6 {\n  margin: 0.5em 0em;\n  page-break-after: avoid\n}\n\n#content h1 { font-size: 140%; }\n#content h2 { font-size: 130%; }\n#content h3 { font-size: 120%; }\n#content h4,\n#content h5,\n#content h6 { font-size: 110%; }\n```\n\nMore styling\n\n```css#+stylesheet\n#content a:hover { color: #aaa; }\n\n#content a:visited,\n#content a { color: #000;}\n\n@media screen {\n  #content a {\n    text-decoration: underline;\n  }\n}\n\n@media print {\n  #content a {\n    text-decoration: none;\n  }\n  #content #doc a[href]:after {\n    content: \" (\" attr(href) \")\";\n    font-size: 90%;\n  }\n}\n```\n\n## Highlight markup\n\n`highlight.js` specific styles for code blocks.\nBasic type markup:\n\n```css#+stylesheet\n.hljs {\n    overflow: auto;\n    padding: 0.5em;\n    color: #333;\n}\n.hljs-comment, .diff .hljs-header, .hljs-javadoc {\n    color: #999;\n    font-style: italic;\n}\n.hljs-keyword, .css .rule .hljs-keyword, .hljs-winutils, .nginx .hljs-title,\n.hljs-subst, .hljs-request, .hljs-status {\n    color: #333;\n    font-weight: bold;\n}\n.hljs-number, .hljs-hexcolor, .ruby .hljs-constant {\n    color: #088;\n}\n.hljs-string, .hljs-tag .hljs-value, .hljs-phpdoc, .hljs-dartdoc, .tex .hljs-formula {\n    color: #d14;\n}\n.hljs-title, .hljs-id, .scss .hljs-preprocessor {\n    color: #900;\n    font-weight: bold;\n}\n.hljs-list .hljs-keyword, .hljs-subst {\n    font-weight: normal;\n}\n.hljs-class .hljs-title, .hljs-type, .vhdl .hljs-literal, .tex .hljs-command {\n    color: #458;\n    font-weight: bold;\n}\n.hljs-tag, .hljs-tag .hljs-title, .hljs-rules .hljs-property, .django .hljs-tag .hljs-keyword {\n    color: #000080;\n    font-weight: normal;\n}\n.hljs-attribute, .hljs-variable, .lisp .hljs-body {\n    color: #008080;\n}\n.hljs-regexp {\n    color: #009926;\n}\n.hljs-built_in {\n    color: #0086b3;\n}\n```\n\nLanguage specific markup\n\n```css#+stylesheet\n.hljs-symbol, .ruby .hljs-symbol .hljs-string, .lisp .hljs-keyword,\n.clojure .hljs-keyword, .scheme .hljs-keyword, .tex .hljs-special,\n.hljs-prompt {\n    color: #990073;\n}\n```\n\nOther uncommon specialize markup:\n\n```css#+stylesheet\n.hljs-preprocessor, .hljs-pragma, .hljs-pi, .hljs-doctype, .hljs-shebang,\n.hljs-cdata {\n    color: #999;\n    font-weight: bold;\n}\n.hljs-deletion {\n    background: #fdd;\n}\n.hljs-addition {\n    background: #dfd;\n}\n.diff .hljs-change {\n    background: #0086b3;\n}\n.hljs-chunk {\n    color: #aaa;\n}\n```\n\nUsing `CSS` it is possibly to have a separate\nlayout for print media.\n`markover` overrides certain values for print media.\n\n```css#+stylesheet\n@media print {\n  .hljs {\n    overflow: visible;\n    word-wrap: break-word;\n  }\n  .hljs-number, .hljs-hexcolor, .ruby .hljs-constant {\n    color: #888;\n  }\n  .hljs-string, .hljs-tag .hljs-value, .hljs-phpdoc, .hljs-dartdoc, .tex .hljs-formula {\n    color: #ddd;\n  }\n  .hljs-title, .hljs-id, .scss .hljs-preprocessor {\n    color: #999;\n  }\n  .hljs-class .hljs-title, .hljs-type, .vhdl .hljs-literal, .tex .hljs-command {\n    color: #888;\n  }\n  .hljs-tag, .hljs-tag .hljs-title, .hljs-rules .hljs-property, .django .hljs-tag .hljs-keyword {\n    color: #888;\n  }\n  .hljs-attribute, .hljs-variable, .lisp .hljs-body {\n    color: #888;\n  }\n  .hljs-regexp {\n    color: #999;\n  }\n  .hljs-symbol, .ruby .hljs-symbol .hljs-string, .lisp .hljs-keyword,\n  .clojure .hljs-keyword, .scheme .hljs-keyword, .tex .hljs-special,\n  .hljs-prompt {\n    color: #999;\n  }\n  .hljs-built_in {\n    color: #888;\n  }\n  .hljs-deletion {\n    background: #ddd;\n  }\n  .hljs-addition {\n    background: #ddd;\n  }\n  .diff .hljs-change {\n    background: #888;\n  }\n}\n```\n\n# Modules\n\n`pry` makes use of several `CommonJS` modules.\nThe code is omitted from the `weave` output.\n\n`markover` provides weave and tangle.\n\n```noweave#+markover\n!(function() {\n\nvar markover = {\n\n\"title\":\"markover\",\n\n\"tag\":\"Web Literate Programming\",\n\n\"version\":\"0.0.1\",\n\n\"head\":\"<!DOCTYPE html>\\n<html lang=\\\"en\\\" class=\\\"\\\">\\n<head>\\n  <meta charset=\\\"utf-8\\\">\\n  <meta http-equiv=\\\"Content-Language\\\" content=\\\"en\\\">\\n  <meta name=\\\"viewport\\\" content=\\\"initial-scale=1\\\">\\n  <script type=\\\"text/x-mathjax-config\\\">\\n    MathJax.Hub.Config({\\n      showProcessingMessages: false,\\n      tex2jax: { inlineMath: [['\\\\\\\\(','\\\\\\\\)']] },\\n      TeX: { equationNumbers: {autoNumber: \\\"AMS\\\"} }\\n    });\\n  </script>\\n  <script type=\\\"text/javascript\\\"\\n    src=\\\"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\\\">\\n  </script>\\n  <script type=\\\"text/javascript\\\"\\n    src=\\\"http://code.jquery.com/jquery-2.1.3.min.js\\\">\\n  </script>\",\n\n\"transition\":\"</head>\\n<body>\",\n\n\"tail\":\"</body>\\n</html>\\n<script type=\\\"text/javascript\\\">\\n  [\\\"bash\\\", \\\"xml\\\", \\\"javascript\\\", \\\"json\\\", \\\"css\\\", \\\"markdown\\\"].forEach(function(e) {\\n    var s = $('<script>')\\n    s.type = 'text/javascript'\\n    s.src = 'http://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/languages/' + e + '.min.js'\\n    $('head').append(s)\\n  })\\n</script>\",\n\n\"headstylesheet\":\"html, body, div, span, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre,\\nabbr, address, cite, code, del, dfn, em, img, ins, kbd, q, samp,\\nsmall, strong, sub, sup, var, b, i, dl, dt, dd, ol, ul, li, a,\\nfieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td,\\narticle, aside, canvas, details, figcaption, figure,\\nfooter, header, hgroup, menu, nav, section, summary, time, mark, audio, video {\\n  display: block;\\n  margin:0;\\n  padding:0;\\n  border:0;\\n  outline:0;\\n  line-height: 140%;\\n  font-size: 100%;\\n  vertical-align:baseline;\\n  text-decoration: none;\\n  background:transparent;\\n}\\n\\na, code, span, b, i, em { display: inline; }\",\n\n\"stylesheet\":\"#content {\\n  font-family: \\\"HelveticaNeue-Light\\\", \\\"Helvetica Neue Light\\\", \\\"Helvetica Neue\\\", Helvetica, Arial, \\\"Lucida Grande\\\", sans-serif; \\n}\\n\\n#content #title {\\n  clear: both;\\n  text-align: center;\\n  font-size: 140%;\\n  font-weight: bold;\\n  margin: 2em 0 0 0;\\n}\\n\\n#content #tag {\\n  clear: both;\\n  text-align: center;\\n  font-size: 110%;\\n  margin: 0 0 1em 0;\\n}\\n#content #toc {\\n  padding: 0 0 0 1em;\\n  max-width: 96%;\\n  page-break-after: always;\\n}\\n\\n@media screen and (min-width: 641px) {\\n  #content #toc {\\n    float: left;\\n    max-width: 26%;\\n  }\\n}\\n\\n#content .tocsn { float: left; }\\n#content .tocsr { overflow: hidden; }\\n\\n#content #toc ol {\\n  list-style-type: none;\\n}\\n\\n#content #toc ol ol {\\n  margin: 0 0 0 1em;\\n}\\n#content #doc,\\n#content #toc {\\n  margin: 0 1em 0 1em;\\n}\\n\\n#content p { text-indent: 1em; }\\n\\n#content code { font-size: 120%; }\\n\\n#content pre code {\\n  font-family: \\\"Courier New\\\", Courier, monospace;\\n  font-size: 100%;\\n}\\n\\n@media screen and (min-width: 641px) {\\n  #content #doc {\\n    overflow: hidden;\\n    max-width: 70%;\\n  }\\n}\\n#content pre .field {\\n  display:block;\\n  margin: 1em 1em 0em 0em;\\n}\\n\\n#content pre .field::after {\\n  content: \\\" :=\\\";\\n}\\n#content pre code {\\n  display: block;\\n  margin: 1em;\\n  padding: 1em;\\n  border: solid 1px #aaa;\\n}\\n\\n@media screen {\\n  #content pre code {\\n    overflow: auto;\\n    max-height: 30em;\\n  }\\n}\\n\\n@media print {\\n  #content pre {\\n    page-break-inside: avoid;\\n  }\\n  #content pre code {\\n    overflow: visible;\\n    word-wrap: break-word;\\n  }\\n}\\n@media screen {\\n  #content .lang-js { background-color: ivory; }\\n  #content .lang-md { background-color: lightyellow; }\\n  #content .lang-html { background-color: floralwhite; }\\n  #content .lang-json { background-color: honeydew; }\\n  #content .lang-css { background-color: cornsilk; }\\n  #content .lang-sh { background-color: lemonchiffon; }\\n}\\n#content h1,\\n#content h2,\\n#content h3,\\n#content h4,\\n#content h5,\\n#content h6 {\\n  margin: 0.5em 0em;\\n  page-break-after: avoid\\n}\\n\\n#content h1 { font-size: 140%; }\\n#content h2 { font-size: 130%; }\\n#content h3 { font-size: 120%; }\\n#content h4,\\n#content h5,\\n#content h6 { font-size: 110%; }\\n#content a:hover { color: #aaa; }\\n\\n#content a:visited,\\n#content a { color: #000;}\\n\\n@media screen {\\n  #content a {\\n    text-decoration: underline;\\n  }\\n}\\n@media print {\\n  #content a {\\n    text-decoration: none;\\n  }\\n  #content #doc a[href]:after {\\n    content: \\\" (\\\" attr(href) \\\")\\\";\\n    font-size: 90%;\\n  }\\n}\\n.hljs {\\n    overflow: auto;\\n    padding: 0.5em;\\n    color: #333;\\n}\\n.hljs-comment, .diff .hljs-header, .hljs-javadoc {\\n    color: #999;\\n    font-style: italic;\\n}\\n.hljs-keyword, .css .rule .hljs-keyword, .hljs-winutils, .nginx .hljs-title,\\n.hljs-subst, .hljs-request, .hljs-status {\\n    color: #333;\\n    font-weight: bold;\\n}\\n.hljs-number, .hljs-hexcolor, .ruby .hljs-constant {\\n    color: #088;\\n}\\n.hljs-string, .hljs-tag .hljs-value, .hljs-phpdoc, .hljs-dartdoc, .tex .hljs-formula {\\n    color: #d14;\\n}\\n.hljs-title, .hljs-id, .scss .hljs-preprocessor {\\n    color: #900;\\n    font-weight: bold;\\n}\\n.hljs-list .hljs-keyword, .hljs-subst {\\n    font-weight: normal;\\n}\\n.hljs-class .hljs-title, .hljs-type, .vhdl .hljs-literal, .tex .hljs-command {\\n    color: #458;\\n    font-weight: bold;\\n}\\n.hljs-tag, .hljs-tag .hljs-title, .hljs-rules .hljs-property, .django .hljs-tag .hljs-keyword {\\n    color: #000080;\\n    font-weight: normal;\\n}\\n.hljs-attribute, .hljs-variable, .lisp .hljs-body {\\n    color: #008080;\\n}\\n.hljs-regexp {\\n    color: #009926;\\n}\\n.hljs-built_in {\\n    color: #0086b3;\\n}\\n\\n.hljs-symbol, .ruby .hljs-symbol .hljs-string, .lisp .hljs-keyword,\\n.clojure .hljs-keyword, .scheme .hljs-keyword, .tex .hljs-special,\\n.hljs-prompt {\\n    color: #990073;\\n}\\n.hljs-preprocessor, .hljs-pragma, .hljs-pi, .hljs-doctype, .hljs-shebang,\\n.hljs-cdata {\\n    color: #999;\\n    font-weight: bold;\\n}\\n.hljs-deletion {\\n    background: #fdd;\\n}\\n.hljs-addition {\\n    background: #dfd;\\n}\\n.diff .hljs-change {\\n    background: #0086b3;\\n}\\n.hljs-chunk {\\n    color: #aaa;\\n}\\n@media print {\\n  .hljs {\\n    overflow: visible;\\n    word-wrap: break-word;\\n  }\\n  .hljs-number, .hljs-hexcolor, .ruby .hljs-constant {\\n    color: #888;\\n  }\\n  .hljs-string, .hljs-tag .hljs-value, .hljs-phpdoc, .hljs-dartdoc, .tex .hljs-formula {\\n    color: #ddd;\\n  }\\n  .hljs-title, .hljs-id, .scss .hljs-preprocessor {\\n    color: #999;\\n  }\\n  .hljs-class .hljs-title, .hljs-type, .vhdl .hljs-literal, .tex .hljs-command {\\n    color: #888;\\n  }\\n  .hljs-tag, .hljs-tag .hljs-title, .hljs-rules .hljs-property, .django .hljs-tag .hljs-keyword {\\n    color: #888;\\n  }\\n  .hljs-attribute, .hljs-variable, .lisp .hljs-body {\\n    color: #888;\\n  }\\n  .hljs-regexp {\\n    color: #999;\\n  }\\n  .hljs-symbol, .ruby .hljs-symbol .hljs-string, .lisp .hljs-keyword,\\n  .clojure .hljs-keyword, .scheme .hljs-keyword, .tex .hljs-special,\\n  .hljs-prompt {\\n    color: #999;\\n  }\\n  .hljs-built_in {\\n    color: #888;\\n  }\\n  .hljs-deletion {\\n    background: #ddd;\\n  }\\n  .hljs-addition {\\n    background: #ddd;\\n  }\\n  .diff .hljs-change {\\n    background: #888;\\n  }\\n}\",\n\n\"pool\":function(options) {\n  options = options || {}\n\n  var dam = new require('stream').Transform()\n  dam.options = options\n  dam.options.convert = dam.options.convert || function(string, options) { return string }\n  dam.options.self = dam.options.self || this\n\n  dam.lake = []\n  dam._transform = function(chunk, encoding, done) {\n    dam.lake.push(chunk.toString())\n    done()\n  }\n\n  dam._flush = function(done) {\n    dam.push(dam.options.convert.call(dam.options.self, dam.lake.join(''), dam.options))\n    dam.push('\\n')\n    dam.lake = []\n    done()\n  }\n\n  return dam\n},\n\n\"escape\":function (html, encode) {\n  return html\n    .replace(!encode ? /&(?!#?\\w+;)/g : /&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;');\n},\n\n\"unescape\":function(html) {\n  return html.replace(/&([#\\w]+);/g, function(_, n) {\n    n = n.toLowerCase();\n    if (n === 'colon') return ':';\n    if (n === 'lt') return '<';\n    if (n === 'gt') return '>';\n    if (n === 'quot') return '\"';\n    if (n.charAt(0) === '#') {\n      return n.charAt(1) === 'x'\n        ? String.fromCharCode(parseInt(n.substring(2), 16))\n        : String.fromCharCode(+n.substring(1));\n    }\n    return '';\n  })\n},\n\n\"tangleFormatPrefix\":\" {%n%n\",\n\n\"tangleFormatSuffix\":\"%n}%n%n\",\n\n\"tangleFormatDelimiter\":\",%n%n\",\n\n\"tangleFormatFieldPrefix\":\"\\\"\",\n\n\"tangleFormatFieldSuffix\":\"\\\":\",\n\n\"tangleFormat\":function(ff, fields, lf) {\n  var res = [ff, this.tangleFormatPrefix]\n  var firsttime = true\n  var v\n  for (var e in fields) {\n    v = fields[e]\n    if (firsttime) {\n      firsttime = false\n    } else {\n      res.push(this.tangleFormatDelimiter)\n    }\n    res.push(this.tangleFormatFieldPrefix + e + this.tangleFormatFieldSuffix)\n    res.push(v)\n  }\n   res.push(this.tangleFormatSuffix)\n   res.push(lf)\n\n   return res.join('')\n     .replace(/%q/gm, '\\\"')\n     .replace(/%n/gm, '\\n')\n     .replace(/%t/gm, '\\t')\n     .replace(/%s/gm, '\\\\')\n     .replace(/%p/gm , '%')\n},\n\n\"tangleJSON\":function (str, options) {\n  options = options || {}\n  options.exclude = options.exclude || []\n  var marked = require('marked')\n  var p = new marked.Renderer()\n  marked.setOptions({\n    renderer: p,\n    gfm: true,\n    tables: true,\n    breaks: false,\n    pedantic: false,\n    sanitize: true,\n    smartLists: true,\n    smartypants: false\n  })\n  p.code = function(code, lang, escaped) {\n\n    if (!lang)\n      return ''\n\n    var field = lang.replace(/\\S*#[+]?(\\S*)/, \"$1\")\n    if (lang == field)\n      return ''\n\n    var quote = lang.replace(/\\S*#([+]?)\\S*/, \"$1\")\n    lang = lang.replace(/(\\S*)#[+]?\\S*/, \"$1\")\n    if (lang == '') lang = 'json'\n\n    if (quote == '+') {\n      code = ('\"' +\n        code\n          .replace(/\\\\/gm, '\\\\\\\\')\n          .replace(/\\\"/gm /*\"*/, '\\\\\"')\n          .replace(/\\n/gm , '\\\\n')\n          .replace(/\\t/gm , '\\\\t')\n        + '\"')\n    }\n\n    var esccode = code\n      .replace(/%/gm , '%p')\n      .replace(/\"/gm /*\"*/, '%q')\n      .replace(/\\n/gm, '%n')\n      .replace(/\\t/gm, '%t')\n      .replace(/\\\\/gm, '%s')\n\n    return ',[\"' + field + '\", \"' + (quote == '+')  + '\", \"' + esccode + '\"]'\n  }\n  function noop() { return ''}\n\n  p.blockquote = noop\n  p.html = noop\n  p.heading = noop\n  p.hr = noop\n  p.list = noop\n  p.listitem = noop\n  p.paragraph = noop\n  p.table = noop\n  p.tablerow = noop\n  p.tablecell = noop\n  p.strong = noop\n  p.em = noop\n  p.codespan = noop\n  p.br = noop\n  p.del = noop\n  p.link = noop\n  p.image = noop\n  var doc = '[' + marked(str).substring(1) + ']'\n  var obj = JSON.parse(doc)\n  var fields = {}\n  var ff = ''\n  var lf = ''\n  var res = obj.forEach(function(e) {\n    var k = e[0]\n    var q = (e[1] == \"true\")\n    var v = e[2]\n    var doit = true\n    if (options.exclude.indexOf(k) != -1)\n      doit = false\n    if (doit) {\n      if (fields[k] != undefined) {\n        if (q) {\n          v = fields[k].substring(0,fields[k].length-2) + '\\\\n' + v.substring(2)\n        } else {\n          v = fields[k] + '%n' + v\n        }\n      }\n      fields[k] = v\n    }\n  })\n  if (fields[\"first\"] != undefined) {\n    ff = fields[\"first\"]\n    delete fields[\"first\"]\n  }\n\n  if (fields[\"last\"] != undefined) {\n    lf = fields[\"last\"]\n    delete fields[\"last\"]\n  }\n\n  if (options.sourcetarget) {\n    fields[options.sourcetarget] = \n        ('\"' +\n          str\n          .replace(/\\\\/gm, '\\\\\\\\')\n          .replace(/\\\"/gm /*\"*/, '\\\\\"')\n          .replace(/\\n/gm , '\\\\n')\n          .replace(/\\t/gm , '\\\\t')\n          .replace(/%/gm , '%p')\n        + '\"')\n  }\n\n  return this.tangleFormat(ff, fields, lf)\n},\n\n\"tangleStream\":function (opts) {\n  var options = {convert: this.tangleJSON, self:this}\n  for(var i in opts)\n    options[i] = opts[i]\n  var p = this.pool(options)\n\n  if (!p.options.notstdio) {\n    process.stdin.pipe(p).pipe(process.stdout)\n    return true\n  }\n\n  return p\n},\n\n\"heading\":function(text, level, raw, toc, prefix) {\n  var i = raw.toLowerCase().replace(/[^\\w]+/g, '-')\n  var n = [0, 0, 0, 0, 0, 0, 0]\n  if (level > 6) level = 6\n  else if (level < 1) level = 1\n  toc.push([text, level, i])\n  var l\n  for (var x = 0; x < toc.length; x++) {\n    l = toc[x][1]\n    n[l] = n[l] + 1\n    while (++l < toc.length)\n      n[l] = 0\n  }\n  var sn = n.slice(1, level+1).join('.') + (level == 1 ? '.' : '')\n  toc[toc.length-1].push(sn)\n  return '<h'\n    + level\n    + ' id=\"'\n    + prefix\n    + i\n    + '\">'\n    + sn + ' ' + text\n    + '</h'\n    + level\n    + '>\\n'\n},\n\n\"weaveHighlight\":function (lang, code) {\n  var hljs = require('highlight.js')\n  code = hljs.highlight(lang, this.unescape(code), true)\n  return code\n},\n\n\"weaveCode\":function(code, lang, escaped, fields, prefix) {\n  var c = code\n  if (!lang) {\n    return '<pre><code>'\n      + this.escape(c)\n      + '\\n</code></pre>'\n  }\n  var i = lang.indexOf('#')\n  if (i == -1) {\n    if (lang == \"noweave\") return ''\n    return '<pre><code class=\"'\n      + prefix\n      + this.escape(lang, true)\n      + '\">'\n      + this.weaveHighlight(lang, c).value\n      + '\\n</code></pre>\\n'\n  }\n  var field = lang.substring(i+1)\n  lang = lang.substring(0, i)\n  if (lang == \"\") lang = \"json\"\n\n  if (field.substring(0,1) == '+') {\n    field = field.substring(1)\n  }\n\n  if (fields[field] == undefined) {\n    fields[field] = c\n  } else {\n    fields[field] = fields[field] + '\\n' + c\n  }\n\n  if (lang == \"noweave\") return ''\n\n  return '<pre><div class=\"field\">'\n    + field + '</div>'\n    + '<code class=\"'\n    + prefix\n    + this.escape(lang, true)\n    + '\">'\n    + this.weaveHighlight((lang != \"\" ? lang : \"json\"), c).value\n    + '\\n</code></pre>\\n'\n},\n\n\"weaveMarked\":function () {\n  var marked = require('marked')\n  var p = new marked.Renderer()\n\n  marked.setOptions({\n    renderer: p,\n    gfm: true,\n    tables: true,\n    breaks: false,\n    pedantic: false,\n    sanitize: true,\n    smartLists: true,\n    smartypants: false\n  })\n  p.field = []\n  p.toc = []\n  p.self = this\n  p.heading = function (text, level, raw) {\n    return this.self.heading.call(this.self, text, level, raw, p.toc, this.options.headerPrefix)\n  }\n  p.code = function (code, lang, escaped) {\n    return this.self.weaveCode.call(this.self, code, lang, escaped, p.field, this.options.langPrefix)\n  }\n\n  return [marked, p]\n},\n\n\"weaveJSON\":function (str, options) {\n  options = options || {}\n  var m = this.weaveMarked()\n  var marked = m[0]\n  var p = m[1]\n  var doc = marked.call(this, str)\n  function f(l,d) { return this.unescape(p.field[l] || d) }\n  var title = f(\"title\", \"Weave Output\")\n  var tag = f(\"tag\", \"from weaving\")\n  var headstylesheet = f(\"headstylesheet\", \"\")\n  var stylesheet = f(\"stylesheet\", \"\")\n\n  var headline = f(\"head\", \"<!DOCTYPE html><html><head>\")\n  var transitionline = f(\"transition\", \"</head><body>\")\n  var tailline = f(\"tail\", \"</body></html>\") + '\\n'\n\n  var headtitle = '<title>' + title + ' - ' + tag + '</title>\\n'\n  var titleline = '<div id=\"title\">' + title + '</div>'\n  var tagline = '<div id=\"tag\">' + tag + '</div>'\n\n  var headstyleline = headstylesheet == '' ? '' : '<style>' + headstylesheet + '</style>'\n  var styleline = stylesheet == '' ? '' : '<style>' + stylesheet + '</style>'\n  var tocitems = p.toc.map(function(e, i, a) {\n    var ll = 0\n    var o = ''\n    if (i > 0) ll = a[i-1][1]\n    if (ll < e[1]) {\n      while (ll++ < e[1])\n        o = o + '<ol>'\n    } else if (ll > e[1]) {\n      while (ll-- > e[1])\n        o = o + '</ol>'\n    }\n    return (\n            o + '<li><div class=\"tocsn\">' + e[3] + '&nbsp;</div><div class=\"tocsr\"><a href=\"#' + e[2] + '\">'\n          + e[0] + '</a></div>'\n           )\n  })\n  var toc = ''\n  var ll\n  var o\n\n  if (p.toc.length > 0) {\n    ll = p.toc[p.toc.length-1][1]\n    o = ''\n    while (ll-- > 0)\n      o = o + '</ol>'\n    toc = '<div id=\"toc\"><h1>Contents</h1>\\n' + tocitems.join('\\n') + o + '</div>\\n'\n  }\n  var heading = ''\n  var tailing = ''\n  if (options.contentonly != true) {\n    heading = headline + headtitle + headstyleline + styleline + transitionline\n    tailing = tailline\n  } else\n    heading = styleline\n\n  return (heading +\n          '<div id=\"content\">' +\n             titleline + tagline + toc +\n          '<div id=\"doc\">' + doc + '</div>' +\n          '</div>' + tailing)\n},\n\n\"weaveStream\":function (opts) {\n  var options = {convert: this.weaveJSON, self:this}\n  for(var i in opts)\n    options[i] = opts[i]\n  var p = this.pool(options)\n\n  if (!p.options.notstdio) {\n    process.stdin.pipe(p).pipe(process.stdout)\n    return true\n  }\n\n  return p\n},\n\n\"untangleStream\":function (opts) {\n  opts = opts || {}\n  var options\n  options = {\n    convert: function (str, options) {\n      return '```\\n' + str + '```\\n'\n    },\n    self: this\n  }\n\n  for(var i in opts)\n    options[i] = opts[i]\n\n  var p = this.pool(options)\n\n  if (!options.notstdio) {\n    process.stdin.pipe(p).pipe(process.stdout)\n    return true\n  }\n\n  return p\n}\n}\n\nif (typeof module !== 'undefined' && typeof exports === 'object') {\n    module.exports = markover\n} else if (typeof define === 'function' && define.amd) {\n    define(function() { return markover })\n} else {\n    this.markover = markover\n}\n\n}).call(function () {\n        return this || (typeof window !== 'undefined' ? window : global)\n})\n```\n\n`markover` depends on `marked` for parsing `markdown` documents.\n\n```noweave#+marked\n/**\n * marked - a markdown parser\n * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/chjj/marked\n */\n\n;(function() {\n\n/**\n * Block-Level Grammar\n */\n\nvar block = {\n  newline: /^\\n+/,\n  code: /^( {4}[^\\n]+\\n*)+/,\n  fences: noop,\n  hr: /^( *[-*_]){3,} *(?:\\n+|$)/,\n  heading: /^ *(#{1,6}) *([^\\n]+?) *#* *(?:\\n+|$)/,\n  nptable: noop,\n  lheading: /^([^\\n]+)\\n *(=|-){2,} *(?:\\n+|$)/,\n  blockquote: /^( *>[^\\n]+(\\n(?!def)[^\\n]+)*\\n*)+/,\n  list: /^( *)(bull) [\\s\\S]+?(?:hr|def|\\n{2,}(?! )(?!\\1bull )\\n*|\\s*$)/,\n  html: /^ *(?:comment|closed|closing) *(?:\\n{2,}|\\s*$)/,\n  def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +[\"(]([^\\n]+)[\")])? *(?:\\n+|$)/,\n  table: noop,\n  paragraph: /^((?:[^\\n]+\\n?(?!hr|heading|lheading|blockquote|tag|def))+)\\n*/,\n  text: /^[^\\n]+/\n};\n\nblock.bullet = /(?:[*+-]|\\d+\\.)/;\nblock.item = /^( *)(bull) [^\\n]*(?:\\n(?!\\1bull )[^\\n]*)*/;\nblock.item = replace(block.item, 'gm')\n  (/bull/g, block.bullet)\n  ();\n\nblock.list = replace(block.list)\n  (/bull/g, block.bullet)\n  ('hr', '\\\\n+(?=\\\\1?(?:[-*_] *){3,}(?:\\\\n+|$))')\n  ('def', '\\\\n+(?=' + block.def.source + ')')\n  ();\n\nblock.blockquote = replace(block.blockquote)\n  ('def', block.def)\n  ();\n\nblock._tag = '(?!(?:'\n  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'\n  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'\n  + '|span|br|wbr|ins|del|img)\\\\b)\\\\w+(?!:/|[^\\\\w\\\\s@]*@)\\\\b';\n\nblock.html = replace(block.html)\n  ('comment', /<!--[\\s\\S]*?-->/)\n  ('closed', /<(tag)[\\s\\S]+?<\\/\\1>/)\n  ('closing', /<tag(?:\"[^\"]*\"|'[^']*'|[^'\">])*?>/)\n  (/tag/g, block._tag)\n  ();\n\nblock.paragraph = replace(block.paragraph)\n  ('hr', block.hr)\n  ('heading', block.heading)\n  ('lheading', block.lheading)\n  ('blockquote', block.blockquote)\n  ('tag', '<' + block._tag)\n  ('def', block.def)\n  ();\n\n/**\n * Normal Block Grammar\n */\n\nblock.normal = merge({}, block);\n\n/**\n * GFM Block Grammar\n */\n\nblock.gfm = merge({}, block.normal, {\n  fences: /^ *(`{3,}|~{3,}) *(\\S+)? *\\n([\\s\\S]+?)\\s*\\1 *(?:\\n+|$)/,\n  paragraph: /^/\n});\n\nblock.gfm.paragraph = replace(block.paragraph)\n  ('(?!', '(?!'\n    + block.gfm.fences.source.replace('\\\\1', '\\\\2') + '|'\n    + block.list.source.replace('\\\\1', '\\\\3') + '|')\n  ();\n\n/**\n * GFM + Tables Block Grammar\n */\n\nblock.tables = merge({}, block.gfm, {\n  nptable: /^ *(\\S.*\\|.*)\\n *([-:]+ *\\|[-| :]*)\\n((?:.*\\|.*(?:\\n|$))*)\\n*/,\n  table: /^ *\\|(.+)\\n *\\|( *[-:]+[-| :]*)\\n((?: *\\|.*(?:\\n|$))*)\\n*/\n});\n\n/**\n * Block Lexer\n */\n\nfunction Lexer(options) {\n  this.tokens = [];\n  this.tokens.links = {};\n  this.options = options || marked.defaults;\n  this.rules = block.normal;\n\n  if (this.options.gfm) {\n    if (this.options.tables) {\n      this.rules = block.tables;\n    } else {\n      this.rules = block.gfm;\n    }\n  }\n}\n\n/**\n * Expose Block Rules\n */\n\nLexer.rules = block;\n\n/**\n * Static Lex Method\n */\n\nLexer.lex = function(src, options) {\n  var lexer = new Lexer(options);\n  return lexer.lex(src);\n};\n\n/**\n * Preprocessing\n */\n\nLexer.prototype.lex = function(src) {\n  src = src\n    .replace(/\\r\\n|\\r/g, '\\n')\n    .replace(/\\t/g, '    ')\n    .replace(/\\u00a0/g, ' ')\n    .replace(/\\u2424/g, '\\n');\n\n  return this.token(src, true);\n};\n\n/**\n * Lexing\n */\n\nLexer.prototype.token = function(src, top, bq) {\n  var src = src.replace(/^ +$/gm, '')\n    , next\n    , loose\n    , cap\n    , bull\n    , b\n    , item\n    , space\n    , i\n    , l;\n\n  while (src) {\n    // newline\n    if (cap = this.rules.newline.exec(src)) {\n      src = src.substring(cap[0].length);\n      if (cap[0].length > 1) {\n        this.tokens.push({\n          type: 'space'\n        });\n      }\n    }\n\n    // code\n    if (cap = this.rules.code.exec(src)) {\n      src = src.substring(cap[0].length);\n      cap = cap[0].replace(/^ {4}/gm, '');\n      this.tokens.push({\n        type: 'code',\n        text: !this.options.pedantic\n          ? cap.replace(/\\n+$/, '')\n          : cap\n      });\n      continue;\n    }\n\n    // fences (gfm)\n    if (cap = this.rules.fences.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'code',\n        lang: cap[2],\n        text: cap[3]\n      });\n      continue;\n    }\n\n    // heading\n    if (cap = this.rules.heading.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'heading',\n        depth: cap[1].length,\n        text: cap[2]\n      });\n      continue;\n    }\n\n    // table no leading pipe (gfm)\n    if (top && (cap = this.rules.nptable.exec(src))) {\n      src = src.substring(cap[0].length);\n\n      item = {\n        type: 'table',\n        header: cap[1].replace(/^ *| *\\| *$/g, '').split(/ *\\| */),\n        align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n        cells: cap[3].replace(/\\n$/, '').split('\\n')\n      };\n\n      for (i = 0; i < item.align.length; i++) {\n        if (/^ *-+: *$/.test(item.align[i])) {\n          item.align[i] = 'right';\n        } else if (/^ *:-+: *$/.test(item.align[i])) {\n          item.align[i] = 'center';\n        } else if (/^ *:-+ *$/.test(item.align[i])) {\n          item.align[i] = 'left';\n        } else {\n          item.align[i] = null;\n        }\n      }\n\n      for (i = 0; i < item.cells.length; i++) {\n        item.cells[i] = item.cells[i].split(/ *\\| */);\n      }\n\n      this.tokens.push(item);\n\n      continue;\n    }\n\n    // lheading\n    if (cap = this.rules.lheading.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'heading',\n        depth: cap[2] === '=' ? 1 : 2,\n        text: cap[1]\n      });\n      continue;\n    }\n\n    // hr\n    if (cap = this.rules.hr.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'hr'\n      });\n      continue;\n    }\n\n    // blockquote\n    if (cap = this.rules.blockquote.exec(src)) {\n      src = src.substring(cap[0].length);\n\n      this.tokens.push({\n        type: 'blockquote_start'\n      });\n\n      cap = cap[0].replace(/^ *> ?/gm, '');\n\n      // Pass `top` to keep the current\n      // \"toplevel\" state. This is exactly\n      // how markdown.pl works.\n      this.token(cap, top, true);\n\n      this.tokens.push({\n        type: 'blockquote_end'\n      });\n\n      continue;\n    }\n\n    // list\n    if (cap = this.rules.list.exec(src)) {\n      src = src.substring(cap[0].length);\n      bull = cap[2];\n\n      this.tokens.push({\n        type: 'list_start',\n        ordered: bull.length > 1\n      });\n\n      // Get each top-level item.\n      cap = cap[0].match(this.rules.item);\n\n      next = false;\n      l = cap.length;\n      i = 0;\n\n      for (; i < l; i++) {\n        item = cap[i];\n\n        // Remove the list item's bullet\n        // so it is seen as the next token.\n        space = item.length;\n        item = item.replace(/^ *([*+-]|\\d+\\.) +/, '');\n\n        // Outdent whatever the\n        // list item contains. Hacky.\n        if (~item.indexOf('\\n ')) {\n          space -= item.length;\n          item = !this.options.pedantic\n            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')\n            : item.replace(/^ {1,4}/gm, '');\n        }\n\n        // Determine whether the next list item belongs here.\n        // Backpedal if it does not belong in this list.\n        if (this.options.smartLists && i !== l - 1) {\n          b = block.bullet.exec(cap[i + 1])[0];\n          if (bull !== b && !(bull.length > 1 && b.length > 1)) {\n            src = cap.slice(i + 1).join('\\n') + src;\n            i = l - 1;\n          }\n        }\n\n        // Determine whether item is loose or not.\n        // Use: /(^|\\n)(?! )[^\\n]+\\n\\n(?!\\s*$)/\n        // for discount behavior.\n        loose = next || /\\n\\n(?!\\s*$)/.test(item);\n        if (i !== l - 1) {\n          next = item.charAt(item.length - 1) === '\\n';\n          if (!loose) loose = next;\n        }\n\n        this.tokens.push({\n          type: loose\n            ? 'loose_item_start'\n            : 'list_item_start'\n        });\n\n        // Recurse.\n        this.token(item, false, bq);\n\n        this.tokens.push({\n          type: 'list_item_end'\n        });\n      }\n\n      this.tokens.push({\n        type: 'list_end'\n      });\n\n      continue;\n    }\n\n    // html\n    if (cap = this.rules.html.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: this.options.sanitize\n          ? 'paragraph'\n          : 'html',\n        pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',\n        text: cap[0]\n      });\n      continue;\n    }\n\n    // def\n    if ((!bq && top) && (cap = this.rules.def.exec(src))) {\n      src = src.substring(cap[0].length);\n      this.tokens.links[cap[1].toLowerCase()] = {\n        href: cap[2],\n        title: cap[3]\n      };\n      continue;\n    }\n\n    // table (gfm)\n    if (top && (cap = this.rules.table.exec(src))) {\n      src = src.substring(cap[0].length);\n\n      item = {\n        type: 'table',\n        header: cap[1].replace(/^ *| *\\| *$/g, '').split(/ *\\| */),\n        align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n        cells: cap[3].replace(/(?: *\\| *)?\\n$/, '').split('\\n')\n      };\n\n      for (i = 0; i < item.align.length; i++) {\n        if (/^ *-+: *$/.test(item.align[i])) {\n          item.align[i] = 'right';\n        } else if (/^ *:-+: *$/.test(item.align[i])) {\n          item.align[i] = 'center';\n        } else if (/^ *:-+ *$/.test(item.align[i])) {\n          item.align[i] = 'left';\n        } else {\n          item.align[i] = null;\n        }\n      }\n\n      for (i = 0; i < item.cells.length; i++) {\n        item.cells[i] = item.cells[i]\n          .replace(/^ *\\| *| *\\| *$/g, '')\n          .split(/ *\\| */);\n      }\n\n      this.tokens.push(item);\n\n      continue;\n    }\n\n    // top-level paragraph\n    if (top && (cap = this.rules.paragraph.exec(src))) {\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'paragraph',\n        text: cap[1].charAt(cap[1].length - 1) === '\\n'\n          ? cap[1].slice(0, -1)\n          : cap[1]\n      });\n      continue;\n    }\n\n    // text\n    if (cap = this.rules.text.exec(src)) {\n      // Top-level should never reach here.\n      src = src.substring(cap[0].length);\n      this.tokens.push({\n        type: 'text',\n        text: cap[0]\n      });\n      continue;\n    }\n\n    if (src) {\n      throw new\n        Error('Infinite loop on byte: ' + src.charCodeAt(0));\n    }\n  }\n\n  return this.tokens;\n};\n\n/**\n * Inline-Level Grammar\n */\n\nvar inline = {\n  escape: /^\\\\([\\\\`*{}\\[\\]()#+\\-.!_>])/,\n  autolink: /^<([^ >]+(@|:\\/)[^ >]+)>/,\n  url: noop,\n  tag: /^<!--[\\s\\S]*?-->|^<\\/?\\w+(?:\"[^\"]*\"|'[^']*'|[^'\">])*?>/,\n  link: /^!?\\[(inside)\\]\\(href\\)/,\n  reflink: /^!?\\[(inside)\\]\\s*\\[([^\\]]*)\\]/,\n  nolink: /^!?\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\]/,\n  strong: /^__([\\s\\S]+?)__(?!_)|^\\*\\*([\\s\\S]+?)\\*\\*(?!\\*)/,\n  em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n  code: /^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/,\n  br: /^ {2,}\\n(?!\\s*$)/,\n  del: noop,\n  text: /^[\\s\\S]+?(?=[\\\\<!\\[_*`]| {2,}\\n|$)/\n};\n\ninline._inside = /(?:\\[[^\\]]*\\]|[^\\[\\]]|\\](?=[^\\[]*\\]))*/;\ninline._href = /\\s*<?([\\s\\S]*?)>?(?:\\s+['\"]([\\s\\S]*?)['\"])?\\s*/;\n\ninline.link = replace(inline.link)\n  ('inside', inline._inside)\n  ('href', inline._href)\n  ();\n\ninline.reflink = replace(inline.reflink)\n  ('inside', inline._inside)\n  ();\n\n/**\n * Normal Inline Grammar\n */\n\ninline.normal = merge({}, inline);\n\n/**\n * Pedantic Inline Grammar\n */\n\ninline.pedantic = merge({}, inline.normal, {\n  strong: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\n  em: /^_(?=\\S)([\\s\\S]*?\\S)_(?!_)|^\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)/\n});\n\n/**\n * GFM Inline Grammar\n */\n\ninline.gfm = merge({}, inline.normal, {\n  escape: replace(inline.escape)('])', '~|])')(),\n  url: /^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/,\n  del: /^~~(?=\\S)([\\s\\S]*?\\S)~~/,\n  text: replace(inline.text)\n    (']|', '~]|')\n    ('|', '|https?://|')\n    ()\n});\n\n/**\n * GFM + Line Breaks Inline Grammar\n */\n\ninline.breaks = merge({}, inline.gfm, {\n  br: replace(inline.br)('{2,}', '*')(),\n  text: replace(inline.gfm.text)('{2,}', '*')()\n});\n\n/**\n * Inline Lexer & Compiler\n */\n\nfunction InlineLexer(links, options) {\n  this.options = options || marked.defaults;\n  this.links = links;\n  this.rules = inline.normal;\n  this.renderer = this.options.renderer || new Renderer;\n  this.renderer.options = this.options;\n\n  if (!this.links) {\n    throw new\n      Error('Tokens array requires a `links` property.');\n  }\n\n  if (this.options.gfm) {\n    if (this.options.breaks) {\n      this.rules = inline.breaks;\n    } else {\n      this.rules = inline.gfm;\n    }\n  } else if (this.options.pedantic) {\n    this.rules = inline.pedantic;\n  }\n}\n\n/**\n * Expose Inline Rules\n */\n\nInlineLexer.rules = inline;\n\n/**\n * Static Lexing/Compiling Method\n */\n\nInlineLexer.output = function(src, links, options) {\n  var inline = new InlineLexer(links, options);\n  return inline.output(src);\n};\n\n/**\n * Lexing/Compiling\n */\n\nInlineLexer.prototype.output = function(src) {\n  var out = ''\n    , link\n    , text\n    , href\n    , cap;\n\n  while (src) {\n    // escape\n    if (cap = this.rules.escape.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += cap[1];\n      continue;\n    }\n\n    // autolink\n    if (cap = this.rules.autolink.exec(src)) {\n      src = src.substring(cap[0].length);\n      if (cap[2] === '@') {\n        text = cap[1].charAt(6) === ':'\n          ? this.mangle(cap[1].substring(7))\n          : this.mangle(cap[1]);\n        href = this.mangle('mailto:') + text;\n      } else {\n        text = escape(cap[1]);\n        href = text;\n      }\n      out += this.renderer.link(href, null, text);\n      continue;\n    }\n\n    // url (gfm)\n    if (!this.inLink && (cap = this.rules.url.exec(src))) {\n      src = src.substring(cap[0].length);\n      text = escape(cap[1]);\n      href = text;\n      out += this.renderer.link(href, null, text);\n      continue;\n    }\n\n    // tag\n    if (cap = this.rules.tag.exec(src)) {\n      if (!this.inLink && /^<a /i.test(cap[0])) {\n        this.inLink = true;\n      } else if (this.inLink && /^<\\/a>/i.test(cap[0])) {\n        this.inLink = false;\n      }\n      src = src.substring(cap[0].length);\n      out += this.options.sanitize\n        ? escape(cap[0])\n        : cap[0];\n      continue;\n    }\n\n    // link\n    if (cap = this.rules.link.exec(src)) {\n      src = src.substring(cap[0].length);\n      this.inLink = true;\n      out += this.outputLink(cap, {\n        href: cap[2],\n        title: cap[3]\n      });\n      this.inLink = false;\n      continue;\n    }\n\n    // reflink, nolink\n    if ((cap = this.rules.reflink.exec(src))\n        || (cap = this.rules.nolink.exec(src))) {\n      src = src.substring(cap[0].length);\n      link = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n      link = this.links[link.toLowerCase()];\n      if (!link || !link.href) {\n        out += cap[0].charAt(0);\n        src = cap[0].substring(1) + src;\n        continue;\n      }\n      this.inLink = true;\n      out += this.outputLink(cap, link);\n      this.inLink = false;\n      continue;\n    }\n\n    // strong\n    if (cap = this.rules.strong.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.renderer.strong(this.output(cap[2] || cap[1]));\n      continue;\n    }\n\n    // em\n    if (cap = this.rules.em.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.renderer.em(this.output(cap[2] || cap[1]));\n      continue;\n    }\n\n    // code\n    if (cap = this.rules.code.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.renderer.codespan(escape(cap[2], true));\n      continue;\n    }\n\n    // br\n    if (cap = this.rules.br.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.renderer.br();\n      continue;\n    }\n\n    // del (gfm)\n    if (cap = this.rules.del.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += this.renderer.del(this.output(cap[1]));\n      continue;\n    }\n\n    // text\n    if (cap = this.rules.text.exec(src)) {\n      src = src.substring(cap[0].length);\n      out += escape(this.smartypants(cap[0]));\n      continue;\n    }\n\n    if (src) {\n      throw new\n        Error('Infinite loop on byte: ' + src.charCodeAt(0));\n    }\n  }\n\n  return out;\n};\n\n/**\n * Compile Link\n */\n\nInlineLexer.prototype.outputLink = function(cap, link) {\n  var href = escape(link.href)\n    , title = link.title ? escape(link.title) : null;\n\n  return cap[0].charAt(0) !== '!'\n    ? this.renderer.link(href, title, this.output(cap[1]))\n    : this.renderer.image(href, title, escape(cap[1]));\n};\n\n/**\n * Smartypants Transformations\n */\n\nInlineLexer.prototype.smartypants = function(text) {\n  if (!this.options.smartypants) return text;\n  return text\n    // em-dashes\n    .replace(/--/g, '\\u2014')\n    // opening singles\n    .replace(/(^|[-\\u2014/(\\[{\"\\s])'/g, '$1\\u2018')\n    // closing singles & apostrophes\n    .replace(/'/g, '\\u2019')\n    // opening doubles\n    .replace(/(^|[-\\u2014/(\\[{\\u2018\\s])\"/g, '$1\\u201c')\n    // closing doubles\n    .replace(/\"/g, '\\u201d')\n    // ellipses\n    .replace(/\\.{3}/g, '\\u2026');\n};\n\n/**\n * Mangle Links\n */\n\nInlineLexer.prototype.mangle = function(text) {\n  var out = ''\n    , l = text.length\n    , i = 0\n    , ch;\n\n  for (; i < l; i++) {\n    ch = text.charCodeAt(i);\n    if (Math.random() > 0.5) {\n      ch = 'x' + ch.toString(16);\n    }\n    out += '&#' + ch + ';';\n  }\n\n  return out;\n};\n\n/**\n * Renderer\n */\n\nfunction Renderer(options) {\n  this.options = options || {};\n}\n\nRenderer.prototype.code = function(code, lang, escaped) {\n  if (this.options.highlight) {\n    var out = this.options.highlight(code, lang);\n    if (out != null && out !== code) {\n      escaped = true;\n      code = out;\n    }\n  }\n\n  if (!lang) {\n    return '<pre><code>'\n      + (escaped ? code : escape(code, true))\n      + '\\n</code></pre>';\n  }\n\n  return '<pre><code class=\"'\n    + this.options.langPrefix\n    + escape(lang, true)\n    + '\">'\n    + (escaped ? code : escape(code, true))\n    + '\\n</code></pre>\\n';\n};\n\nRenderer.prototype.blockquote = function(quote) {\n  return '<blockquote>\\n' + quote + '</blockquote>\\n';\n};\n\nRenderer.prototype.html = function(html) {\n  return html;\n};\n\nRenderer.prototype.heading = function(text, level, raw) {\n  return '<h'\n    + level\n    + ' id=\"'\n    + this.options.headerPrefix\n    + raw.toLowerCase().replace(/[^\\w]+/g, '-')\n    + '\">'\n    + text\n    + '</h'\n    + level\n    + '>\\n';\n};\n\nRenderer.prototype.hr = function() {\n  return this.options.xhtml ? '<hr/>\\n' : '<hr>\\n';\n};\n\nRenderer.prototype.list = function(body, ordered) {\n  var type = ordered ? 'ol' : 'ul';\n  return '<' + type + '>\\n' + body + '</' + type + '>\\n';\n};\n\nRenderer.prototype.listitem = function(text) {\n  return '<li>' + text + '</li>\\n';\n};\n\nRenderer.prototype.paragraph = function(text) {\n  return '<p>' + text + '</p>\\n';\n};\n\nRenderer.prototype.table = function(header, body) {\n  return '<table>\\n'\n    + '<thead>\\n'\n    + header\n    + '</thead>\\n'\n    + '<tbody>\\n'\n    + body\n    + '</tbody>\\n'\n    + '</table>\\n';\n};\n\nRenderer.prototype.tablerow = function(content) {\n  return '<tr>\\n' + content + '</tr>\\n';\n};\n\nRenderer.prototype.tablecell = function(content, flags) {\n  var type = flags.header ? 'th' : 'td';\n  var tag = flags.align\n    ? '<' + type + ' style=\"text-align:' + flags.align + '\">'\n    : '<' + type + '>';\n  return tag + content + '</' + type + '>\\n';\n};\n\n// span level renderer\nRenderer.prototype.strong = function(text) {\n  return '<strong>' + text + '</strong>';\n};\n\nRenderer.prototype.em = function(text) {\n  return '<em>' + text + '</em>';\n};\n\nRenderer.prototype.codespan = function(text) {\n  return '<code>' + text + '</code>';\n};\n\nRenderer.prototype.br = function() {\n  return this.options.xhtml ? '<br/>' : '<br>';\n};\n\nRenderer.prototype.del = function(text) {\n  return '<del>' + text + '</del>';\n};\n\nRenderer.prototype.link = function(href, title, text) {\n  if (this.options.sanitize) {\n    try {\n      var prot = decodeURIComponent(unescape(href))\n        .replace(/[^\\w:]/g, '')\n        .toLowerCase();\n    } catch (e) {\n      return '';\n    }\n    if (prot.indexOf('javascript:') === 0) {\n      return '';\n    }\n  }\n  var out = '<a href=\"' + href + '\"';\n  if (title) {\n    out += ' title=\"' + title + '\"';\n  }\n  out += '>' + text + '</a>';\n  return out;\n};\n\nRenderer.prototype.image = function(href, title, text) {\n  var out = '<img src=\"' + href + '\" alt=\"' + text + '\"';\n  if (title) {\n    out += ' title=\"' + title + '\"';\n  }\n  out += this.options.xhtml ? '/>' : '>';\n  return out;\n};\n\n/**\n * Parsing & Compiling\n */\n\nfunction Parser(options) {\n  this.tokens = [];\n  this.token = null;\n  this.options = options || marked.defaults;\n  this.options.renderer = this.options.renderer || new Renderer;\n  this.renderer = this.options.renderer;\n  this.renderer.options = this.options;\n}\n\n/**\n * Static Parse Method\n */\n\nParser.parse = function(src, options, renderer) {\n  var parser = new Parser(options, renderer);\n  return parser.parse(src);\n};\n\n/**\n * Parse Loop\n */\n\nParser.prototype.parse = function(src) {\n  this.inline = new InlineLexer(src.links, this.options, this.renderer);\n  this.tokens = src.reverse();\n\n  var out = '';\n  while (this.next()) {\n    out += this.tok();\n  }\n\n  return out;\n};\n\n/**\n * Next Token\n */\n\nParser.prototype.next = function() {\n  return this.token = this.tokens.pop();\n};\n\n/**\n * Preview Next Token\n */\n\nParser.prototype.peek = function() {\n  return this.tokens[this.tokens.length - 1] || 0;\n};\n\n/**\n * Parse Text Tokens\n */\n\nParser.prototype.parseText = function() {\n  var body = this.token.text;\n\n  while (this.peek().type === 'text') {\n    body += '\\n' + this.next().text;\n  }\n\n  return this.inline.output(body);\n};\n\n/**\n * Parse Current Token\n */\n\nParser.prototype.tok = function() {\n  switch (this.token.type) {\n    case 'space': {\n      return '';\n    }\n    case 'hr': {\n      return this.renderer.hr();\n    }\n    case 'heading': {\n      return this.renderer.heading(\n        this.inline.output(this.token.text),\n        this.token.depth,\n        this.token.text);\n    }\n    case 'code': {\n      return this.renderer.code(this.token.text,\n        this.token.lang,\n        this.token.escaped);\n    }\n    case 'table': {\n      var header = ''\n        , body = ''\n        , i\n        , row\n        , cell\n        , flags\n        , j;\n\n      // header\n      cell = '';\n      for (i = 0; i < this.token.header.length; i++) {\n        flags = { header: true, align: this.token.align[i] };\n        cell += this.renderer.tablecell(\n          this.inline.output(this.token.header[i]),\n          { header: true, align: this.token.align[i] }\n        );\n      }\n      header += this.renderer.tablerow(cell);\n\n      for (i = 0; i < this.token.cells.length; i++) {\n        row = this.token.cells[i];\n\n        cell = '';\n        for (j = 0; j < row.length; j++) {\n          cell += this.renderer.tablecell(\n            this.inline.output(row[j]),\n            { header: false, align: this.token.align[j] }\n          );\n        }\n\n        body += this.renderer.tablerow(cell);\n      }\n      return this.renderer.table(header, body);\n    }\n    case 'blockquote_start': {\n      var body = '';\n\n      while (this.next().type !== 'blockquote_end') {\n        body += this.tok();\n      }\n\n      return this.renderer.blockquote(body);\n    }\n    case 'list_start': {\n      var body = ''\n        , ordered = this.token.ordered;\n\n      while (this.next().type !== 'list_end') {\n        body += this.tok();\n      }\n\n      return this.renderer.list(body, ordered);\n    }\n    case 'list_item_start': {\n      var body = '';\n\n      while (this.next().type !== 'list_item_end') {\n        body += this.token.type === 'text'\n          ? this.parseText()\n          : this.tok();\n      }\n\n      return this.renderer.listitem(body);\n    }\n    case 'loose_item_start': {\n      var body = '';\n\n      while (this.next().type !== 'list_item_end') {\n        body += this.tok();\n      }\n\n      return this.renderer.listitem(body);\n    }\n    case 'html': {\n      var html = !this.token.pre && !this.options.pedantic\n        ? this.inline.output(this.token.text)\n        : this.token.text;\n      return this.renderer.html(html);\n    }\n    case 'paragraph': {\n      return this.renderer.paragraph(this.inline.output(this.token.text));\n    }\n    case 'text': {\n      return this.renderer.paragraph(this.parseText());\n    }\n  }\n};\n\n/**\n * Helpers\n */\n\nfunction escape(html, encode) {\n  return html\n    .replace(!encode ? /&(?!#?\\w+;)/g : /&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#39;');\n}\n\nfunction unescape(html) {\n  return html.replace(/&([#\\w]+);/g, function(_, n) {\n    n = n.toLowerCase();\n    if (n === 'colon') return ':';\n    if (n.charAt(0) === '#') {\n      return n.charAt(1) === 'x'\n        ? String.fromCharCode(parseInt(n.substring(2), 16))\n        : String.fromCharCode(+n.substring(1));\n    }\n    return '';\n  });\n}\n\nfunction replace(regex, opt) {\n  regex = regex.source;\n  opt = opt || '';\n  return function self(name, val) {\n    if (!name) return new RegExp(regex, opt);\n    val = val.source || val;\n    val = val.replace(/(^|[^\\[])\\^/g, '$1');\n    regex = regex.replace(name, val);\n    return self;\n  };\n}\n\nfunction noop() {}\nnoop.exec = noop;\n\nfunction merge(obj) {\n  var i = 1\n    , target\n    , key;\n\n  for (; i < arguments.length; i++) {\n    target = arguments[i];\n    for (key in target) {\n      if (Object.prototype.hasOwnProperty.call(target, key)) {\n        obj[key] = target[key];\n      }\n    }\n  }\n\n  return obj;\n}\n\n\n/**\n * Marked\n */\n\nfunction marked(src, opt, callback) {\n  if (callback || typeof opt === 'function') {\n    if (!callback) {\n      callback = opt;\n      opt = null;\n    }\n\n    opt = merge({}, marked.defaults, opt || {});\n\n    var highlight = opt.highlight\n      , tokens\n      , pending\n      , i = 0;\n\n    try {\n      tokens = Lexer.lex(src, opt)\n    } catch (e) {\n      return callback(e);\n    }\n\n    pending = tokens.length;\n\n    var done = function() {\n      var out, err;\n\n      try {\n        out = Parser.parse(tokens, opt);\n      } catch (e) {\n        err = e;\n      }\n\n      opt.highlight = highlight;\n\n      return err\n        ? callback(err)\n        : callback(null, out);\n    };\n\n    if (!highlight || highlight.length < 3) {\n      return done();\n    }\n\n    delete opt.highlight;\n\n    if (!pending) return done();\n\n    for (; i < tokens.length; i++) {\n      (function(token) {\n        if (token.type !== 'code') {\n          return --pending || done();\n        }\n        return highlight(token.text, token.lang, function(err, code) {\n          if (code == null || code === token.text) {\n            return --pending || done();\n          }\n          token.text = code;\n          token.escaped = true;\n          --pending || done();\n        });\n      })(tokens[i]);\n    }\n\n    return;\n  }\n  try {\n    if (opt) opt = merge({}, marked.defaults, opt);\n    return Parser.parse(Lexer.lex(src, opt), opt);\n  } catch (e) {\n    e.message += '\\nPlease report this to https://github.com/chjj/marked.';\n    if ((opt || marked.defaults).silent) {\n      return '<p>An error occured:</p><pre>'\n        + escape(e.message + '', true)\n        + '</pre>';\n    }\n    throw e;\n  }\n}\n\n/**\n * Options\n */\n\nmarked.options =\nmarked.setOptions = function(opt) {\n  merge(marked.defaults, opt);\n  return marked;\n};\n\nmarked.defaults = {\n  gfm: true,\n  tables: true,\n  breaks: false,\n  pedantic: false,\n  sanitize: false,\n  smartLists: false,\n  silent: false,\n  highlight: null,\n  langPrefix: 'lang-',\n  smartypants: false,\n  headerPrefix: '',\n  renderer: new Renderer,\n  xhtml: false\n};\n\n/**\n * Expose\n */\n\nmarked.Parser = Parser;\nmarked.parser = Parser.parse;\n\nmarked.Renderer = Renderer;\n\nmarked.Lexer = Lexer;\nmarked.lexer = Lexer.lex;\n\nmarked.InlineLexer = InlineLexer;\nmarked.inlineLexer = InlineLexer.output;\n\nmarked.parse = marked;\n\nif (typeof exports === 'object') {\n  module.exports = marked;\n} else if (typeof define === 'function' && define.amd) {\n  define(function() { return marked; });\n} else {\n  this.marked = marked;\n}\n\n}).call(function() {\n  return this || (typeof window !== 'undefined' ? window : global);\n}());\n```\n\n`markover` depends on `highlight.js` for source code syntax\nhighlighting.\n\nMy version of `highlight.js` reimplements the 'index.js' file in the\ndistribution.\nIt requires 'highlight_highlight.js' and then requires all the languages\nthat are used in the document and registers them\n\nThis seems to leave require.loaded with 2 versions of highlight: the\nraw version without any languages and this one which has the languages\nincluded.\n\n```noweave#+highlight.js\n(function() {\n\nvar hljs = require('highlight_highlight.js')\nhljs.registerLanguage('bash',       require('highlight_bash.js'))\nhljs.registerLanguage('xml',        require('highlight_xml.js'))\nhljs.registerLanguage('javascript', require('highlight_javascript.js'))\nhljs.registerLanguage('json',       require('highlight_json.js'))\nhljs.registerLanguage('css',        require('highlight_css.js'))\nhljs.registerLanguage('markdown',   require('highlight_markdown.js'))\n\nif (typeof exports === 'object') {\n  module.exports = hljs\n} else if (typeof define === 'function' && define.amd) {\n  define(function() { return hljs; });\n} else {\n  this.hljs = hljs;\n}\n\n}).call(function() {\n  return this || (typeof window !== 'undefined' ? window : global);\n}())\n```\n\n```noweave#+highlight_highlight.js\n/*\nSyntax highlighting with language autodetection.\nhttps://highlightjs.org/\n*/\n\n(function(factory) {\n\n  // Setup highlight.js for different environments. First is Node.js or\n  // CommonJS.\n  if(typeof exports !== 'undefined') {\n    factory(exports);\n  } else {\n    // Export hljs globally even when using AMD for cases when this script\n    // is loaded with others that may still expect a global hljs.\n    window.hljs = factory({});\n\n    // Finally register the global hljs with AMD.\n    if(typeof define === 'function' && define.amd) {\n      define([], function() {\n        return window.hljs;\n      });\n    }\n  }\n\n}(function(hljs) {\n\n  /* Utility functions */\n\n  function escape(value) {\n    return value.replace(/&/gm, '&amp;').replace(/</gm, '&lt;').replace(/>/gm, '&gt;');\n  }\n\n  function tag(node) {\n    return node.nodeName.toLowerCase();\n  }\n\n  function testRe(re, lexeme) {\n    var match = re && re.exec(lexeme);\n    return match && match.index == 0;\n  }\n\n  function blockLanguage(block) {\n    var classes = (block.className + ' ' + (block.parentNode ? block.parentNode.className : '')).split(/\\s+/);\n    classes = classes.map(function(c) {return c.replace(/^lang(uage)?-/, '');});\n    return classes.filter(function(c) {return getLanguage(c) || /no(-?)highlight/.test(c);})[0];\n  }\n\n  function inherit(parent, obj) {\n    var result = {};\n    for (var key in parent)\n      result[key] = parent[key];\n    if (obj)\n      for (var key in obj)\n        result[key] = obj[key];\n    return result;\n  };\n\n  /* Stream merging */\n\n  function nodeStream(node) {\n    var result = [];\n    (function _nodeStream(node, offset) {\n      for (var child = node.firstChild; child; child = child.nextSibling) {\n        if (child.nodeType == 3)\n          offset += child.nodeValue.length;\n        else if (child.nodeType == 1) {\n          result.push({\n            event: 'start',\n            offset: offset,\n            node: child\n          });\n          offset = _nodeStream(child, offset);\n          // Prevent void elements from having an end tag that would actually\n          // double them in the output. There are more void elements in HTML\n          // but we list only those realistically expected in code display.\n          if (!tag(child).match(/br|hr|img|input/)) {\n            result.push({\n              event: 'stop',\n              offset: offset,\n              node: child\n            });\n          }\n        }\n      }\n      return offset;\n    })(node, 0);\n    return result;\n  }\n\n  function mergeStreams(original, highlighted, value) {\n    var processed = 0;\n    var result = '';\n    var nodeStack = [];\n\n    function selectStream() {\n      if (!original.length || !highlighted.length) {\n        return original.length ? original : highlighted;\n      }\n      if (original[0].offset != highlighted[0].offset) {\n        return (original[0].offset < highlighted[0].offset) ? original : highlighted;\n      }\n\n      /*\n      To avoid starting the stream just before it should stop the order is\n      ensured that original always starts first and closes last:\n\n      if (event1 == 'start' && event2 == 'start')\n        return original;\n      if (event1 == 'start' && event2 == 'stop')\n        return highlighted;\n      if (event1 == 'stop' && event2 == 'start')\n        return original;\n      if (event1 == 'stop' && event2 == 'stop')\n        return highlighted;\n\n      ... which is collapsed to:\n      */\n      return highlighted[0].event == 'start' ? original : highlighted;\n    }\n\n    function open(node) {\n      function attr_str(a) {return ' ' + a.nodeName + '=\"' + escape(a.value) + '\"';}\n      result += '<' + tag(node) + Array.prototype.map.call(node.attributes, attr_str).join('') + '>';\n    }\n\n    function close(node) {\n      result += '</' + tag(node) + '>';\n    }\n\n    function render(event) {\n      (event.event == 'start' ? open : close)(event.node);\n    }\n\n    while (original.length || highlighted.length) {\n      var stream = selectStream();\n      result += escape(value.substr(processed, stream[0].offset - processed));\n      processed = stream[0].offset;\n      if (stream == original) {\n        /*\n        On any opening or closing tag of the original markup we first close\n        the entire highlighted node stack, then render the original tag along\n        with all the following original tags at the same offset and then\n        reopen all the tags on the highlighted stack.\n        */\n        nodeStack.reverse().forEach(close);\n        do {\n          render(stream.splice(0, 1)[0]);\n          stream = selectStream();\n        } while (stream == original && stream.length && stream[0].offset == processed);\n        nodeStack.reverse().forEach(open);\n      } else {\n        if (stream[0].event == 'start') {\n          nodeStack.push(stream[0].node);\n        } else {\n          nodeStack.pop();\n        }\n        render(stream.splice(0, 1)[0]);\n      }\n    }\n    return result + escape(value.substr(processed));\n  }\n\n  /* Initialization */\n\n  function compileLanguage(language) {\n\n    function reStr(re) {\n        return (re && re.source) || re;\n    }\n\n    function langRe(value, global) {\n      return RegExp(\n        reStr(value),\n        'm' + (language.case_insensitive ? 'i' : '') + (global ? 'g' : '')\n      );\n    }\n\n    function compileMode(mode, parent) {\n      if (mode.compiled)\n        return;\n      mode.compiled = true;\n\n      mode.keywords = mode.keywords || mode.beginKeywords;\n      if (mode.keywords) {\n        var compiled_keywords = {};\n\n        var flatten = function(className, str) {\n          if (language.case_insensitive) {\n            str = str.toLowerCase();\n          }\n          str.split(' ').forEach(function(kw) {\n            var pair = kw.split('|');\n            compiled_keywords[pair[0]] = [className, pair[1] ? Number(pair[1]) : 1];\n          });\n        };\n\n        if (typeof mode.keywords == 'string') { // string\n          flatten('keyword', mode.keywords);\n        } else {\n          Object.keys(mode.keywords).forEach(function (className) {\n            flatten(className, mode.keywords[className]);\n          });\n        }\n        mode.keywords = compiled_keywords;\n      }\n      mode.lexemesRe = langRe(mode.lexemes || /\\b[A-Za-z0-9_]+\\b/, true);\n\n      if (parent) {\n        if (mode.beginKeywords) {\n          mode.begin = '\\\\b(' + mode.beginKeywords.split(' ').join('|') + ')\\\\b';\n        }\n        if (!mode.begin)\n          mode.begin = /\\B|\\b/;\n        mode.beginRe = langRe(mode.begin);\n        if (!mode.end && !mode.endsWithParent)\n          mode.end = /\\B|\\b/;\n        if (mode.end)\n          mode.endRe = langRe(mode.end);\n        mode.terminator_end = reStr(mode.end) || '';\n        if (mode.endsWithParent && parent.terminator_end)\n          mode.terminator_end += (mode.end ? '|' : '') + parent.terminator_end;\n      }\n      if (mode.illegal)\n        mode.illegalRe = langRe(mode.illegal);\n      if (mode.relevance === undefined)\n        mode.relevance = 1;\n      if (!mode.contains) {\n        mode.contains = [];\n      }\n      var expanded_contains = [];\n      mode.contains.forEach(function(c) {\n        if (c.variants) {\n          c.variants.forEach(function(v) {expanded_contains.push(inherit(c, v));});\n        } else {\n          expanded_contains.push(c == 'self' ? mode : c);\n        }\n      });\n      mode.contains = expanded_contains;\n      mode.contains.forEach(function(c) {compileMode(c, mode);});\n\n      if (mode.starts) {\n        compileMode(mode.starts, parent);\n      }\n\n      var terminators =\n        mode.contains.map(function(c) {\n          return c.beginKeywords ? '\\\\.?(' + c.begin + ')\\\\.?' : c.begin;\n        })\n        .concat([mode.terminator_end, mode.illegal])\n        .map(reStr)\n        .filter(Boolean);\n      mode.terminators = terminators.length ? langRe(terminators.join('|'), true) : {exec: function(s) {return null;}};\n    }\n\n    compileMode(language);\n  }\n\n  /*\n  Core highlighting function. Accepts a language name, or an alias, and a\n  string with the code to highlight. Returns an object with the following\n  properties:\n\n  - relevance (int)\n  - value (an HTML string with highlighting markup)\n\n  */\n  function highlight(name, value, ignore_illegals, continuation) {\n\n    function subMode(lexeme, mode) {\n      for (var i = 0; i < mode.contains.length; i++) {\n        if (testRe(mode.contains[i].beginRe, lexeme)) {\n          return mode.contains[i];\n        }\n      }\n    }\n\n    function endOfMode(mode, lexeme) {\n      if (testRe(mode.endRe, lexeme)) {\n        return mode;\n      }\n      if (mode.endsWithParent) {\n        return endOfMode(mode.parent, lexeme);\n      }\n    }\n\n    function isIllegal(lexeme, mode) {\n      return !ignore_illegals && testRe(mode.illegalRe, lexeme);\n    }\n\n    function keywordMatch(mode, match) {\n      var match_str = language.case_insensitive ? match[0].toLowerCase() : match[0];\n      return mode.keywords.hasOwnProperty(match_str) && mode.keywords[match_str];\n    }\n\n    function buildSpan(classname, insideSpan, leaveOpen, noPrefix) {\n      var classPrefix = noPrefix ? '' : options.classPrefix,\n          openSpan    = '<span class=\"' + classPrefix,\n          closeSpan   = leaveOpen ? '' : '</span>';\n\n      openSpan += classname + '\">';\n\n      return openSpan + insideSpan + closeSpan;\n    }\n\n    function processKeywords() {\n      if (!top.keywords)\n        return escape(mode_buffer);\n      var result = '';\n      var last_index = 0;\n      top.lexemesRe.lastIndex = 0;\n      var match = top.lexemesRe.exec(mode_buffer);\n      while (match) {\n        result += escape(mode_buffer.substr(last_index, match.index - last_index));\n        var keyword_match = keywordMatch(top, match);\n        if (keyword_match) {\n          relevance += keyword_match[1];\n          result += buildSpan(keyword_match[0], escape(match[0]));\n        } else {\n          result += escape(match[0]);\n        }\n        last_index = top.lexemesRe.lastIndex;\n        match = top.lexemesRe.exec(mode_buffer);\n      }\n      return result + escape(mode_buffer.substr(last_index));\n    }\n\n    function processSubLanguage() {\n      if (top.subLanguage && !languages[top.subLanguage]) {\n        return escape(mode_buffer);\n      }\n      var result = top.subLanguage ? highlight(top.subLanguage, mode_buffer, true, continuations[top.subLanguage]) : highlightAuto(mode_buffer);\n      // Counting embedded language score towards the host language may be disabled\n      // with zeroing the containing mode relevance. Usecase in point is Markdown that\n      // allows XML everywhere and makes every XML snippet to have a much larger Markdown\n      // score.\n      if (top.relevance > 0) {\n        relevance += result.relevance;\n      }\n      if (top.subLanguageMode == 'continuous') {\n        continuations[top.subLanguage] = result.top;\n      }\n      return buildSpan(result.language, result.value, false, true);\n    }\n\n    function processBuffer() {\n      return top.subLanguage !== undefined ? processSubLanguage() : processKeywords();\n    }\n\n    function startNewMode(mode, lexeme) {\n      var markup = mode.className? buildSpan(mode.className, '', true): '';\n      if (mode.returnBegin) {\n        result += markup;\n        mode_buffer = '';\n      } else if (mode.excludeBegin) {\n        result += escape(lexeme) + markup;\n        mode_buffer = '';\n      } else {\n        result += markup;\n        mode_buffer = lexeme;\n      }\n      top = Object.create(mode, {parent: {value: top}});\n    }\n\n    function processLexeme(buffer, lexeme) {\n\n      mode_buffer += buffer;\n      if (lexeme === undefined) {\n        result += processBuffer();\n        return 0;\n      }\n\n      var new_mode = subMode(lexeme, top);\n      if (new_mode) {\n        result += processBuffer();\n        startNewMode(new_mode, lexeme);\n        return new_mode.returnBegin ? 0 : lexeme.length;\n      }\n\n      var end_mode = endOfMode(top, lexeme);\n      if (end_mode) {\n        var origin = top;\n        if (!(origin.returnEnd || origin.excludeEnd)) {\n          mode_buffer += lexeme;\n        }\n        result += processBuffer();\n        do {\n          if (top.className) {\n            result += '</span>';\n          }\n          relevance += top.relevance;\n          top = top.parent;\n        } while (top != end_mode.parent);\n        if (origin.excludeEnd) {\n          result += escape(lexeme);\n        }\n        mode_buffer = '';\n        if (end_mode.starts) {\n          startNewMode(end_mode.starts, '');\n        }\n        return origin.returnEnd ? 0 : lexeme.length;\n      }\n\n      if (isIllegal(lexeme, top))\n        throw new Error('Illegal lexeme \"' + lexeme + '\" for mode \"' + (top.className || '<unnamed>') + '\"');\n\n      /*\n      Parser should not reach this point as all types of lexemes should be caught\n      earlier, but if it does due to some bug make sure it advances at least one\n      character forward to prevent infinite looping.\n      */\n      mode_buffer += lexeme;\n      return lexeme.length || 1;\n    }\n\n    var language = getLanguage(name);\n    if (!language) {\n      throw new Error('Unknown language: \"' + name + '\"');\n    }\n\n    compileLanguage(language);\n    var top = continuation || language;\n    var continuations = {}; // keep continuations for sub-languages\n    var result = '';\n    for(var current = top; current != language; current = current.parent) {\n      if (current.className) {\n        result = buildSpan(current.className, '', true) + result;\n      }\n    }\n    var mode_buffer = '';\n    var relevance = 0;\n    try {\n      var match, count, index = 0;\n      while (true) {\n        top.terminators.lastIndex = index;\n        match = top.terminators.exec(value);\n        if (!match)\n          break;\n        count = processLexeme(value.substr(index, match.index - index), match[0]);\n        index = match.index + count;\n      }\n      processLexeme(value.substr(index));\n      for(var current = top; current.parent; current = current.parent) { // close dangling modes\n        if (current.className) {\n          result += '</span>';\n        }\n      };\n      return {\n        relevance: relevance,\n        value: result,\n        language: name,\n        top: top\n      };\n    } catch (e) {\n      if (e.message.indexOf('Illegal') != -1) {\n        return {\n          relevance: 0,\n          value: escape(value)\n        };\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  /*\n  Highlighting with language detection. Accepts a string with the code to\n  highlight. Returns an object with the following properties:\n\n  - language (detected language)\n  - relevance (int)\n  - value (an HTML string with highlighting markup)\n  - second_best (object with the same structure for second-best heuristically\n    detected language, may be absent)\n\n  */\n  function highlightAuto(text, languageSubset) {\n    languageSubset = languageSubset || options.languages || Object.keys(languages);\n    var result = {\n      relevance: 0,\n      value: escape(text)\n    };\n    var second_best = result;\n    languageSubset.forEach(function(name) {\n      if (!getLanguage(name)) {\n        return;\n      }\n      var current = highlight(name, text, false);\n      current.language = name;\n      if (current.relevance > second_best.relevance) {\n        second_best = current;\n      }\n      if (current.relevance > result.relevance) {\n        second_best = result;\n        result = current;\n      }\n    });\n    if (second_best.language) {\n      result.second_best = second_best;\n    }\n    return result;\n  }\n\n  /*\n  Post-processing of the highlighted markup:\n\n  - replace TABs with something more useful\n  - replace real line-breaks with '<br>' for non-pre containers\n\n  */\n  function fixMarkup(value) {\n    if (options.tabReplace) {\n      value = value.replace(/^((<[^>]+>|\\t)+)/gm, function(match, p1, offset, s) {\n        return p1.replace(/\\t/g, options.tabReplace);\n      });\n    }\n    if (options.useBR) {\n      value = value.replace(/\\n/g, '<br>');\n    }\n    return value;\n  }\n\n  function buildClassName(prevClassName, currentLang, resultLang) {\n    var language = currentLang ? aliases[currentLang] : resultLang,\n        result   = [prevClassName.trim()];\n\n    if (!prevClassName.match(/(\\s|^)hljs(\\s|$)/)) {\n      result.push('hljs');\n    }\n\n    if (language) {\n      result.push(language);\n    }\n\n    return result.join(' ').trim();\n  }\n\n  /*\n  Applies highlighting to a DOM node containing code. Accepts a DOM node and\n  two optional parameters for fixMarkup.\n  */\n  function highlightBlock(block) {\n    var language = blockLanguage(block);\n    if (/no(-?)highlight/.test(language))\n        return;\n\n    var node;\n    if (options.useBR) {\n      node = document.createElementNS('http://www.w3.org/1999/xhtml', 'div');\n      node.innerHTML = block.innerHTML.replace(/\\n/g, '').replace(/<br[ \\/]*>/g, '\\n');\n    } else {\n      node = block;\n    }\n    var text = node.textContent;\n    var result = language ? highlight(language, text, true) : highlightAuto(text);\n\n    var originalStream = nodeStream(node);\n    if (originalStream.length) {\n      var resultNode = document.createElementNS('http://www.w3.org/1999/xhtml', 'div');\n      resultNode.innerHTML = result.value;\n      result.value = mergeStreams(originalStream, nodeStream(resultNode), text);\n    }\n    result.value = fixMarkup(result.value);\n\n    block.innerHTML = result.value;\n    block.className = buildClassName(block.className, language, result.language);\n    block.result = {\n      language: result.language,\n      re: result.relevance\n    };\n    if (result.second_best) {\n      block.second_best = {\n        language: result.second_best.language,\n        re: result.second_best.relevance\n      };\n    }\n  }\n\n  var options = {\n    classPrefix: 'hljs-',\n    tabReplace: null,\n    useBR: false,\n    languages: undefined\n  };\n\n  /*\n  Updates highlight.js global options with values passed in the form of an object\n  */\n  function configure(user_options) {\n    options = inherit(options, user_options);\n  }\n\n  /*\n  Applies highlighting to all <pre><code>..</code></pre> blocks on a page.\n  */\n  function initHighlighting() {\n    if (initHighlighting.called)\n      return;\n    initHighlighting.called = true;\n\n    var blocks = document.querySelectorAll('pre code');\n    Array.prototype.forEach.call(blocks, highlightBlock);\n  }\n\n  /*\n  Attaches highlighting to the page load event.\n  */\n  function initHighlightingOnLoad() {\n    addEventListener('DOMContentLoaded', initHighlighting, false);\n    addEventListener('load', initHighlighting, false);\n  }\n\n  var languages = {};\n  var aliases = {};\n\n  function registerLanguage(name, language) {\n    var lang = languages[name] = language(hljs);\n    if (lang.aliases) {\n      lang.aliases.forEach(function(alias) {aliases[alias] = name;});\n    }\n  }\n\n  function listLanguages() {\n    return Object.keys(languages);\n  }\n\n  function getLanguage(name) {\n    return languages[name] || languages[aliases[name]];\n  }\n\n  /* Interface definition */\n\n  hljs.highlight = highlight;\n  hljs.highlightAuto = highlightAuto;\n  hljs.fixMarkup = fixMarkup;\n  hljs.highlightBlock = highlightBlock;\n  hljs.configure = configure;\n  hljs.initHighlighting = initHighlighting;\n  hljs.initHighlightingOnLoad = initHighlightingOnLoad;\n  hljs.registerLanguage = registerLanguage;\n  hljs.listLanguages = listLanguages;\n  hljs.getLanguage = getLanguage;\n  hljs.inherit = inherit;\n\n  // Common regexps\n  hljs.IDENT_RE = '[a-zA-Z][a-zA-Z0-9_]*';\n  hljs.UNDERSCORE_IDENT_RE = '[a-zA-Z_][a-zA-Z0-9_]*';\n  hljs.NUMBER_RE = '\\\\b\\\\d+(\\\\.\\\\d+)?';\n  hljs.C_NUMBER_RE = '(\\\\b0[xX][a-fA-F0-9]+|(\\\\b\\\\d+(\\\\.\\\\d*)?|\\\\.\\\\d+)([eE][-+]?\\\\d+)?)'; // 0x..., 0..., decimal, float\n  hljs.BINARY_NUMBER_RE = '\\\\b(0b[01]+)'; // 0b...\n  hljs.RE_STARTERS_RE = '!|!=|!==|%|%=|&|&&|&=|\\\\*|\\\\*=|\\\\+|\\\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\\\?|\\\\[|\\\\{|\\\\(|\\\\^|\\\\^=|\\\\||\\\\|=|\\\\|\\\\||~';\n\n  // Common modes\n  hljs.BACKSLASH_ESCAPE = {\n    begin: '\\\\\\\\[\\\\s\\\\S]', relevance: 0\n  };\n  hljs.APOS_STRING_MODE = {\n    className: 'string',\n    begin: '\\'', end: '\\'',\n    illegal: '\\\\n',\n    contains: [hljs.BACKSLASH_ESCAPE]\n  };\n  hljs.QUOTE_STRING_MODE = {\n    className: 'string',\n    begin: '\"', end: '\"',\n    illegal: '\\\\n',\n    contains: [hljs.BACKSLASH_ESCAPE]\n  };\n  hljs.PHRASAL_WORDS_MODE = {\n    begin: /\\b(a|an|the|are|I|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such)\\b/\n  };\n  hljs.C_LINE_COMMENT_MODE = {\n    className: 'comment',\n    begin: '//', end: '$',\n    contains: [hljs.PHRASAL_WORDS_MODE]\n  };\n  hljs.C_BLOCK_COMMENT_MODE = {\n    className: 'comment',\n    begin: '/\\\\*', end: '\\\\*/',\n    contains: [hljs.PHRASAL_WORDS_MODE]\n  };\n  hljs.HASH_COMMENT_MODE = {\n    className: 'comment',\n    begin: '#', end: '$',\n    contains: [hljs.PHRASAL_WORDS_MODE]\n  };\n  hljs.NUMBER_MODE = {\n    className: 'number',\n    begin: hljs.NUMBER_RE,\n    relevance: 0\n  };\n  hljs.C_NUMBER_MODE = {\n    className: 'number',\n    begin: hljs.C_NUMBER_RE,\n    relevance: 0\n  };\n  hljs.BINARY_NUMBER_MODE = {\n    className: 'number',\n    begin: hljs.BINARY_NUMBER_RE,\n    relevance: 0\n  };\n  hljs.CSS_NUMBER_MODE = {\n    className: 'number',\n    begin: hljs.NUMBER_RE + '(' +\n      '%|em|ex|ch|rem'  +\n      '|vw|vh|vmin|vmax' +\n      '|cm|mm|in|pt|pc|px' +\n      '|deg|grad|rad|turn' +\n      '|s|ms' +\n      '|Hz|kHz' +\n      '|dpi|dpcm|dppx' +\n      ')?',\n    relevance: 0\n  };\n  hljs.REGEXP_MODE = {\n    className: 'regexp',\n    begin: /\\//, end: /\\/[gimuy]*/,\n    illegal: /\\n/,\n    contains: [\n      hljs.BACKSLASH_ESCAPE,\n      {\n        begin: /\\[/, end: /\\]/,\n        relevance: 0,\n        contains: [hljs.BACKSLASH_ESCAPE]\n      }\n    ]\n  };\n  hljs.TITLE_MODE = {\n    className: 'title',\n    begin: hljs.IDENT_RE,\n    relevance: 0\n  };\n  hljs.UNDERSCORE_TITLE_MODE = {\n    className: 'title',\n    begin: hljs.UNDERSCORE_IDENT_RE,\n    relevance: 0\n  };\n\n  return hljs;\n}));\n```\n\n```noweave#+highlight_bash.js\nmodule.exports = function(hljs) {\n  var VAR = {\n    className: 'variable',\n    variants: [\n      {begin: /\\$[\\w\\d#@][\\w\\d_]*/},\n      {begin: /\\$\\{(.*?)\\}/}\n    ]\n  };\n  var QUOTE_STRING = {\n    className: 'string',\n    begin: /\"/, end: /\"/,\n    contains: [\n      hljs.BACKSLASH_ESCAPE,\n      VAR,\n      {\n        className: 'variable',\n        begin: /\\$\\(/, end: /\\)/,\n        contains: [hljs.BACKSLASH_ESCAPE]\n      }\n    ]\n  };\n  var APOS_STRING = {\n    className: 'string',\n    begin: /'/, end: /'/\n  };\n\n  return {\n    aliases: ['sh', 'zsh'],\n    lexemes: /-?[a-z\\.]+/,\n    keywords: {\n      keyword:\n        'if then else elif fi for while in do done case esac function',\n      literal:\n        'true false',\n      built_in:\n        // Shell built-ins\n        // http://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html\n        'break cd continue eval exec exit export getopts hash pwd readonly return shift test times ' +\n        'trap umask unset ' +\n        // Bash built-ins\n        'alias bind builtin caller command declare echo enable help let local logout mapfile printf ' +\n        'read readarray source type typeset ulimit unalias ' +\n        // Shell modifiers\n        'set shopt ' +\n        // Zsh built-ins\n        'autoload bg bindkey bye cap chdir clone comparguments compcall compctl compdescribe compfiles ' +\n        'compgroups compquote comptags comptry compvalues dirs disable disown echotc echoti emulate ' +\n        'fc fg float functions getcap getln history integer jobs kill limit log noglob popd print ' +\n        'pushd pushln rehash sched setcap setopt stat suspend ttyctl unfunction unhash unlimit ' +\n        'unsetopt vared wait whence where which zcompile zformat zftp zle zmodload zparseopts zprof ' +\n        'zpty zregexparse zsocket zstyle ztcp',\n      operator:\n        '-ne -eq -lt -gt -f -d -e -s -l -a' // relevance booster\n    },\n    contains: [\n      {\n        className: 'shebang',\n        begin: /^#![^\\n]+sh\\s*$/,\n        relevance: 10\n      },\n      {\n        className: 'function',\n        begin: /\\w[\\w\\d_]*\\s*\\(\\s*\\)\\s*\\{/,\n        returnBegin: true,\n        contains: [hljs.inherit(hljs.TITLE_MODE, {begin: /\\w[\\w\\d_]*/})],\n        relevance: 0\n      },\n      hljs.HASH_COMMENT_MODE,\n      hljs.NUMBER_MODE,\n      QUOTE_STRING,\n      APOS_STRING,\n      VAR\n    ]\n  };\n};\n```\n\n```noweave#+highlight_xml.js\nmodule.exports = function(hljs) {\n  var XML_IDENT_RE = '[A-Za-z0-9\\\\._:-]+';\n  var PHP = {\n    begin: /<\\?(php)?(?!\\w)/, end: /\\?>/,\n    subLanguage: 'php', subLanguageMode: 'continuous'\n  };\n  var TAG_INTERNALS = {\n    endsWithParent: true,\n    illegal: /</,\n    relevance: 0,\n    contains: [\n      PHP,\n      {\n        className: 'attribute',\n        begin: XML_IDENT_RE,\n        relevance: 0\n      },\n      {\n        begin: '=',\n        relevance: 0,\n        contains: [\n          {\n            className: 'value',\n            contains: [PHP],\n            variants: [\n              {begin: /\"/, end: /\"/},\n              {begin: /'/, end: /'/},\n              {begin: /[^\\s\\/>]+/}\n            ]\n          }\n        ]\n      }\n    ]\n  };\n  return {\n    aliases: ['html', 'xhtml', 'rss', 'atom', 'xsl', 'plist'],\n    case_insensitive: true,\n    contains: [\n      {\n        className: 'doctype',\n        begin: '<!DOCTYPE', end: '>',\n        relevance: 10,\n        contains: [{begin: '\\\\[', end: '\\\\]'}]\n      },\n      {\n        className: 'comment',\n        begin: '<!--', end: '-->',\n        relevance: 10\n      },\n      {\n        className: 'cdata',\n        begin: '<\\\\!\\\\[CDATA\\\\[', end: '\\\\]\\\\]>',\n        relevance: 10\n      },\n      {\n        className: 'tag',\n        /*\n        The lookahead pattern (?=...) ensures that 'begin' only matches\n        '<style' as a single word, followed by a whitespace or an\n        ending braket. The '$' is needed for the lexeme to be recognized\n        by hljs.subMode() that tests lexemes outside the stream.\n        */\n        begin: '<style(?=\\\\s|>|$)', end: '>',\n        keywords: {title: 'style'},\n        contains: [TAG_INTERNALS],\n        starts: {\n          end: '</style>', returnEnd: true,\n          subLanguage: 'css'\n        }\n      },\n      {\n        className: 'tag',\n        // See the comment in the <style tag about the lookahead pattern\n        begin: '<script(?=\\\\s|>|$)', end: '>',\n        keywords: {title: 'script'},\n        contains: [TAG_INTERNALS],\n        starts: {\n          end: '</script>', returnEnd: true,\n          subLanguage: 'javascript'\n        }\n      },\n      PHP,\n      {\n        className: 'pi',\n        begin: /<\\?\\w+/, end: /\\?>/,\n        relevance: 10\n      },\n      {\n        className: 'tag',\n        begin: '</?', end: '/?>',\n        contains: [\n          {\n            className: 'title', begin: /[^ \\/><\\n\\t]+/, relevance: 0\n          },\n          TAG_INTERNALS\n        ]\n      }\n    ]\n  };\n};\n```\n\n```noweave#+highlight_javascript.js\nmodule.exports = function(hljs) {\n  return {\n    aliases: ['js'],\n    keywords: {\n      keyword:\n        'in if for while finally var new function do return void else break catch ' +\n        'instanceof with throw case default try this switch continue typeof delete ' +\n        'let yield const class',\n      literal:\n        'true false null undefined NaN Infinity',\n      built_in:\n        'eval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent ' +\n        'encodeURI encodeURIComponent escape unescape Object Function Boolean Error ' +\n        'EvalError InternalError RangeError ReferenceError StopIteration SyntaxError ' +\n        'TypeError URIError Number Math Date String RegExp Array Float32Array ' +\n        'Float64Array Int16Array Int32Array Int8Array Uint16Array Uint32Array ' +\n        'Uint8Array Uint8ClampedArray ArrayBuffer DataView JSON Intl arguments require ' +\n        'module console window document'\n    },\n    contains: [\n      {\n        className: 'pi',\n        relevance: 10,\n        variants: [\n          {begin: /^\\s*('|\")use strict('|\")/},\n          {begin: /^\\s*('|\")use asm('|\")/}\n        ]\n      },\n      hljs.APOS_STRING_MODE,\n      hljs.QUOTE_STRING_MODE,\n      hljs.C_LINE_COMMENT_MODE,\n      hljs.C_BLOCK_COMMENT_MODE,\n      hljs.C_NUMBER_MODE,\n      { // \"value\" container\n        begin: '(' + hljs.RE_STARTERS_RE + '|\\\\b(case|return|throw)\\\\b)\\\\s*',\n        keywords: 'return throw case',\n        contains: [\n          hljs.C_LINE_COMMENT_MODE,\n          hljs.C_BLOCK_COMMENT_MODE,\n          hljs.REGEXP_MODE,\n          { // E4X\n            begin: /</, end: />;/,\n            relevance: 0,\n            subLanguage: 'xml'\n          }\n        ],\n        relevance: 0\n      },\n      {\n        className: 'function',\n        beginKeywords: 'function', end: /\\{/, excludeEnd: true,\n        contains: [\n          hljs.inherit(hljs.TITLE_MODE, {begin: /[A-Za-z$_][0-9A-Za-z$_]*/}),\n          {\n            className: 'params',\n            begin: /\\(/, end: /\\)/,\n            contains: [\n              hljs.C_LINE_COMMENT_MODE,\n              hljs.C_BLOCK_COMMENT_MODE\n            ],\n            illegal: /[\"'\\(]/\n          }\n        ],\n        illegal: /\\[|%/\n      },\n      {\n        begin: /\\$[(.]/ // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`\n      },\n      {\n        begin: '\\\\.' + hljs.IDENT_RE, relevance: 0 // hack: prevents detection of keywords after dots\n      }\n    ]\n  };\n};\n```\n\n```noweave#+highlight_json.js\nmodule.exports = function(hljs) {\n  var LITERALS = {literal: 'true false null'};\n  var TYPES = [\n    hljs.QUOTE_STRING_MODE,\n    hljs.C_NUMBER_MODE\n  ];\n  var VALUE_CONTAINER = {\n    className: 'value',\n    end: ',', endsWithParent: true, excludeEnd: true,\n    contains: TYPES,\n    keywords: LITERALS\n  };\n  var OBJECT = {\n    begin: '{', end: '}',\n    contains: [\n      {\n        className: 'attribute',\n        begin: '\\\\s*\"', end: '\"\\\\s*:\\\\s*', excludeBegin: true, excludeEnd: true,\n        contains: [hljs.BACKSLASH_ESCAPE],\n        illegal: '\\\\n',\n        starts: VALUE_CONTAINER\n      }\n    ],\n    illegal: '\\\\S'\n  };\n  var ARRAY = {\n    begin: '\\\\[', end: '\\\\]',\n    contains: [hljs.inherit(VALUE_CONTAINER, {className: null})], // inherit is also a workaround for a bug that makes shared modes with endsWithParent compile only the ending of one of the parents\n    illegal: '\\\\S'\n  };\n  TYPES.splice(TYPES.length, 0, OBJECT, ARRAY);\n  return {\n    contains: TYPES,\n    keywords: LITERALS,\n    illegal: '\\\\S'\n  };\n};\n```\n\n```noweave#+highlight_css.js\nmodule.exports = function(hljs) {\n  var IDENT_RE = '[a-zA-Z-][a-zA-Z0-9_-]*';\n  var FUNCTION = {\n    className: 'function',\n    begin: IDENT_RE + '\\\\(',\n    returnBegin: true,\n    excludeEnd: true,\n    end: '\\\\('\n  };\n  return {\n    case_insensitive: true,\n    illegal: '[=/|\\']',\n    contains: [\n      hljs.C_BLOCK_COMMENT_MODE,\n      {\n        className: 'id', begin: '\\\\#[A-Za-z0-9_-]+'\n      },\n      {\n        className: 'class', begin: '\\\\.[A-Za-z0-9_-]+',\n        relevance: 0\n      },\n      {\n        className: 'attr_selector',\n        begin: '\\\\[', end: '\\\\]',\n        illegal: '$'\n      },\n      {\n        className: 'pseudo',\n        begin: ':(:)?[a-zA-Z0-9\\\\_\\\\-\\\\+\\\\(\\\\)\\\\\"\\\\\\']+'\n      },\n      {\n        className: 'at_rule',\n        begin: '@(font-face|page)',\n        lexemes: '[a-z-]+',\n        keywords: 'font-face page'\n      },\n      {\n        className: 'at_rule',\n        begin: '@', end: '[{;]', // at_rule eating first \"{\" is a good thing\n                                 // because it doesn’t let it to be parsed as\n                                 // a rule set but instead drops parser into\n                                 // the default mode which is how it should be.\n        contains: [\n          {\n            className: 'keyword',\n            begin: /\\S+/\n          },\n          {\n            begin: /\\s/, endsWithParent: true, excludeEnd: true,\n            relevance: 0,\n            contains: [\n              FUNCTION,\n              hljs.APOS_STRING_MODE, hljs.QUOTE_STRING_MODE,\n              hljs.CSS_NUMBER_MODE\n            ]\n          }\n        ]\n      },\n      {\n        className: 'tag', begin: IDENT_RE,\n        relevance: 0\n      },\n      {\n        className: 'rules',\n        begin: '{', end: '}',\n        illegal: '[^\\\\s]',\n        relevance: 0,\n        contains: [\n          hljs.C_BLOCK_COMMENT_MODE,\n          {\n            className: 'rule',\n            begin: '[^\\\\s]', returnBegin: true, end: ';', endsWithParent: true,\n            contains: [\n              {\n                className: 'attribute',\n                begin: '[A-Z\\\\_\\\\.\\\\-]+', end: ':',\n                excludeEnd: true,\n                illegal: '[^\\\\s]',\n                starts: {\n                  className: 'value',\n                  endsWithParent: true, excludeEnd: true,\n                  contains: [\n                    FUNCTION,\n                    hljs.CSS_NUMBER_MODE,\n                    hljs.QUOTE_STRING_MODE,\n                    hljs.APOS_STRING_MODE,\n                    hljs.C_BLOCK_COMMENT_MODE,\n                    {\n                      className: 'hexcolor', begin: '#[0-9A-Fa-f]+'\n                    },\n                    {\n                      className: 'important', begin: '!important'\n                    }\n                  ]\n                }\n              }\n            ]\n          }\n        ]\n      }\n    ]\n  };\n};\n```\n\n```noweave#+highlight_markdown.js\nmodule.exports = function(hljs) {\n  return {\n    aliases: ['md', 'mkdown', 'mkd'],\n    contains: [\n      // highlight headers\n      {\n        className: 'header',\n        variants: [\n          { begin: '^#{1,6}', end: '$' },\n          { begin: '^.+?\\\\n[=-]{2,}$' }\n        ]\n      },\n      // inline html\n      {\n        begin: '<', end: '>',\n        subLanguage: 'xml',\n        relevance: 0\n      },\n      // lists (indicators only)\n      {\n        className: 'bullet',\n        begin: '^([*+-]|(\\\\d+\\\\.))\\\\s+'\n      },\n      // strong segments\n      {\n        className: 'strong',\n        begin: '[*_]{2}.+?[*_]{2}'\n      },\n      // emphasis segments\n      {\n        className: 'emphasis',\n        variants: [\n          { begin: '\\\\*.+?\\\\*' },\n          { begin: '_.+?_'\n          , relevance: 0\n          }\n        ]\n      },\n      // blockquotes\n      {\n        className: 'blockquote',\n        begin: '^>\\\\s+', end: '$'\n      },\n      // code snippets\n      {\n        className: 'code',\n        variants: [\n          { begin: '`.+?`' },\n          { begin: '^( {4}|\\t)', end: '$'\n          , relevance: 0\n          }\n        ]\n      },\n      // horizontal rules\n      {\n        className: 'horizontal_rule',\n        begin: '^[-\\\\*]{3,}', end: '$'\n      },\n      // using links - title and link\n      {\n        begin: '\\\\[.+?\\\\][\\\\(\\\\[].*?[\\\\)\\\\]]',\n        returnBegin: true,\n        contains: [\n          {\n            className: 'link_label',\n            begin: '\\\\[', end: '\\\\]',\n            excludeBegin: true,\n            returnEnd: true,\n            relevance: 0\n          },\n          {\n            className: 'link_url',\n            begin: '\\\\]\\\\(', end: '\\\\)',\n            excludeBegin: true, excludeEnd: true\n          },\n          {\n            className: 'link_reference',\n            begin: '\\\\]\\\\[', end: '\\\\]',\n            excludeBegin: true, excludeEnd: true\n          }\n        ],\n        relevance: 10\n      },\n      {\n        begin: '^\\\\[\\.+\\\\]:',\n        returnBegin: true,\n        contains: [\n          {\n            className: 'link_reference',\n            begin: '\\\\[', end: '\\\\]:',\n            excludeBegin: true, excludeEnd: true,\n            starts: {\n              className: 'link_url',\n              end: '$'\n            }\n          }\n        ]\n      }\n    ]\n  };\n};\n```\n\n# Sharing the Code\n\nUsing the CouchDB replicator, the JSON version of this document\ncan be moved from one CouchDB to another.\n\nOr, select the [README.json](README.json) then copy and paste\nthe document to your CouchDB.\n\nIf you have `markover` installed, then use the following to build\na `JSON` object.\n\n```sh\nnode -e \"require('markover').tangleStream({sourcetarget: 'README.md'})\" < README.md > pry.json\n```\n\nAnd the following for the `HTML` documentation.\n\n```sh\nnode -e \"require('markover').weaveStream()\" < README.md > index.html\n```\n\nThe display of this 'README.md' file on GitHub is readable, but not\nquite right since GitHub doesn't process the field names for the code\nblocks.\nThe generated [index.html](http://cygnyx.github.io/pry) file is better.\nAlso on GitHub you can copy and paste the [pry.json](http://cygnyx.github.io/pry/pry.json)\nfile into the `CouchDB` database.\n\n# Final Thoughts\n\nAlthough the existing editor works well enough, a more sophisticated\neditor would be useful for large projects.\nIt should be possible to change to the [ACE](http://ace.c9.io) editor.\nI made minor changes in the markdown mode to work with hash tagged field\nnames, adding json submode, etc. Another interesting approach would be\nthe [Hallo](http://hallojs.org) editor. \n\nClearly tools like `kanso` provide many additional facilities for\ndeploying a `CouchApp`.\nMany of these capabilities could be included in `pry`.\nBut before implementing more capabilities, I will try using\nthe existing system for a while.\n\nIn order to bootstap `pry` on a `CouchDB` I wrote\na separate `nodejs` utility that used\n`markover` to tangle the source document and then\nupload the `JSON` to the `CouchDB`.\nRun the utility as follows:\n\n```sh\nnode update.js < README.md\n```\n\nTo verify that the editor was working properly,\nI would make minor changes to the documentation and code.\nBut the bulk of the editing occured on my local machine.\nThis brings into question whether `pry` works effectively.\n\nI've excluded the source from the documentation.\n\n```noweave\nvar markover = require('../markover/markover.js')\n\nvar it = {\n  gather: function (res, done) {\n    var buf = []\n    res.on('data', function(chunk) {\n      buf.push(chunk.toString())\n    })\n    res.on('end', function(chunk) {\n      done(buf.join(''))\n    })\n  },\n\n  updateDesignDocument: function(uri, opts) {\n    options = opts || {}\n    var url = require('url')\n    var http = require('http')\n    var ddoc = url.parse(uri)\n\n    http.get(uri, function(res) {\n      it.gather(res, update)\n    }).on('error', function(e) {\n      console.log('ERROR: ' + e.message)\n    })\n\n    function update(res) {\n      var obj = JSON.parse(res)\n      it.rev = obj._rev\n      it.gather(process.stdin, update0)\n    }\n\n    function update0(res) {\n      var str = markover.tangleJSON(res)\n      var obj = JSON.parse(str)\n      obj._rev = it.rev\n      obj['README.md'] = res\n\n      var req = http.request({host: ddoc.host,\n        port: ddoc.port || '80',\n        path: ddoc.path,\n        method: 'PUT'\n      }, function(res) {\n        it.gather(res, update2)\n      })\n\n      req.write(JSON.stringify(obj))\n      req.end()\n    }\n\n    function update2(res) {\n      var obj = JSON.parse(res)\n      if (!obj.ok) {\n        console.log('ERROR: ', JSON.stringify(obj))\n      } else {\n        console.log('INFO: rev', obj.rev)\n      }\n    }\n  }\n}\n\nit.updateDesignDocument('http://localhost/example/_design/pry')\n```\n\nSomewhat surprisingly it is possible to edit documents on\nmobile devices.\nThe `pry` document does take some time to tangle and weave\non a mobile device.\n\nI was able to copy and paste the `pry` JSON to deploy it on `Cloudant`.\nAnd it is able to update itself on it.\n\nAlthough attachments are not consistent with the 'one' in, 'one' out\nstructure of `pry`, there is a clear utility in supporting attachments.\n\nBeing able to insert code could help with the layout of the shows field.\nCurrently, the embedded anonymous functions are simple, yet hard to\nunderstand. Being able to insert a quoted function into the middle of\nthe shows structure is certainly a solution. Another possibility is to\nbreak the shows structure apart, like:\n\n    ```#shows\n    {\n      \"404\" :\n    ```\n    \n    ```#+shows\n    function(doc, req) {\n      return {\n        body: '<h1>404 - Document not found</h1>\\n',\n        headers: {'Content-Type': 'text/html'}\n      }\n    },\n    ```\n    \n    etc.\n    \n    ```#shows\n    }\n    ```\n\nThis would make the shows functions much more readable.\nHowever, this requires a change to `markover` to handle\nappending quoted fields to non-quoted fields.\n"
}


